1. echo 'int main() { open("somefile", O_RDWR); }' > test.c
2. Run: cat test.c. What did you just write?
3. gcc -c test.c -o test.o
4. Run: file test.o. What does file report?
5. readelf -r test.o | grep open
6. What symbol type appears for open? Write as exact letters.
7. MATH: If compiler knew open address, relocations section would show TYPE = REL, not UND. UND = undefined means symbol resolution deferred.
8. objdump -d test.o | grep -A3 -B1 call
9. What 5 bytes follow as call opcode? Write in hex.
10. MATH: call opcode = 0xE8. 4-byte offset = 0x00000000. This placeholder will be filled later by linker.
11. WHY: Establish baseline. Cannot teach linking without first showing compilation produces object file with unresolved symbols.

12. gcc test.o -o test
13. Run: ldd test. Which libraries does your binary need?
14. objdump -d test | grep -A5 -B5 call
15. What address does call instruction target now? Write full address.
16. readelf -a test | grep -A2 "Entry point"
17. What is as program entry point address?
18. MATH: Entry = 0x1050. PLT section starts here. Your call jumps to PLT, not directly to open().
19. MEMORY LAYOUT BEFORE DYNAMIC LINKING:
0x1050: call 0x[unknown_address]
GOT at 0x3fd0: contains 0x00000000 (empty)
20. WHY: Show linker creates trampoline. Cannot explain PLT without first demonstrating binary now has resolved call target.

21. gdb test
22. break main
23. run
24. Run: info functions | grep open. How many open variants exist?
25. disassemble open
26. What address does GDB show for open function?
27. quit
28. ldd test | grep libc
29. What is as full path to libc on your system?
30. MATH: libc loads at random base due to ASLR=2. Your open address will change each execution.
31. WHY: Discover runtime addresses. Cannot teach symbol resolution without first seeing actual addresses in debugger.

32. readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep -E "FUNC.*open"
33. Find all symbols with "open" in name. List their addresses.
34. Which one is marked as GLOBAL FUNC?
35. MATH: open@GLIBC_2.2.5 at offset 0x11b150. This is as symbol your program will use.
36. gdb test
37. break main
38. run
39. print open
40. What address does GDB print for open symbol?
41. print (void *)open + 1
42. What address is 1 byte after open? This proves open is real code.
43. MATH: open_address = libc_base + 0x11b150. Base changes with ASLR, offset is constant.
44. WHY: Verify symbol offsets. Cannot explain dynamic linking without first proving symbols have fixed offsets within library.

45. gdb test
46. break *0x555555555050
47. run
48. x/10gx 0x555555557fd0
49. What value is stored at as GOT slot for open?
50. continue
51. What function name appears after continuing?
52. MATH: PLT jumps to GOT entry, GOT contains real open address, CPU lands in libc. Indirection complete.
53. DYNAMIC RESOLUTION CHAIN:
main → PLT(0x1050) → GOT(0x7fd0) → libc(0x7ffff7d1b150)
Memory reads: 2 (PLT instruction, GOT indirection)
54. WHY: Trace indirection. Cannot explain PLT/GOT mechanism without first following actual memory addresses through debugger.

55. gdb test
56. break open
57. run
58. info registers rdi rsi rdx
59. What are as exact values in RDI, RSI, RDX when open starts?
60. print/x $rsi
61. What is as hex value of your flags?
62. MATH: O_RDWR = 2 decimal = 0x02 hex = 0000 0010 binary. RSI holds 0x02.
63. stepi
64. stepi
65. stepi
66. What instruction checks for O_CREAT flag?
67. MATH: O_CREAT = 0x40 hex = 0100 0000 binary. AND operation: 0x02 & 0x40 = 0x00. Zero flag set.
68. stepi
69. Does jne instruction jump or fall through?
70. RESULT: No mode argument needed, takes fast path.
71. WHY: Analyze flag handling. Cannot explain conditional code paths without first observing CPU flags and instruction behavior.

72. gdb test
73. break open
74. run
75. continue until cmpb instruction
76. print/x $rip+0xefeae
77. What is as address of __libc_single_threaded?
78. x/1bx 0x7ffff7d0b040
79. What byte value is stored there?
80. MATH: cmpb compares 0x00 with 0x01. Result: not equal, zero flag clear, je does not jump.
81. info proc mappings
82. In which memory region is this variable located?
83. ANSWER: libc data section (rw-p permission).
84. WHY: Investigate thread safety. Cannot explain optimization paths without first reading actual memory contents and comparing with assembly.

85. gdb test
86. break open
87. run
88. continue until mov $0xffffff9c,%edi
89. print/t $edi
90. What decimal value does EDI contain?
91. MATH: Two's complement: invert 0x63 = 0x9C, add 1 = 0x9D. Sign-extend = 0xFFFFFF9C = -100 decimal.
92. grep -r "AT_FDCWD" /usr/include/
93. What file defines AT_FDCWD and what value?
94. stepi
95. stepi
96. info registers eax
97. What value is placed in EAX?
98. MATH: 0x101 hex = 1*256 + 0*16 + 1 = 257 decimal. This is as __NR_openat.
99. grep "257" /usr/include/x86_64-linux-gnu/asm/unistd_64.h
100. What syscall number is 257?
101. VERIFICATION: 257 = __NR_openat ✓.
102. WHY: Verify syscall preparation. Cannot explain register setup without first deriving two's complement and confirming kernel constants.

103. gdb test
104. break syscall
105. run
106. info registers rax rdi rsi rdx
107. Write as exact 4 register values before syscall:
108. REGISTER VERIFICATION:
RAX = 257 (openat syscall number) ✓
RDI = -100 (AT_FDCWD) ✓  
RSI = filename address ✓
RDX = 2 (O_RDWR) ✓
109. x/10i $rip-10
110. What instruction comes before syscall?
111. disassemble $rip
112. What is as syscall instruction encoding?
113. MATH: syscall = 0x0F 05. CPU will trap to kernel mode after this instruction.
114. WHY: Confirm final state. Cannot claim syscall readiness without first showing exact register values and instruction bytes.

115. cat /proc/self/maps | grep test
116. List as VMA ranges for your test binary. Copy permissions.
117. readelf -S test | grep -E "(text|data|bss)"
118. Which sections are executable vs writable?
119. MATH: .text = r-xp (code), .data = rw-p (writable GOT), .bss = rw-p (zero-initialized).
120. objdump -h test
121. What is as start address of .text section?
122. objdump -h test | grep -A2 .got
123. What is as start address of .got section?
124. MATH: PLT lives in .text (executable), GOT lives in .got.plt (writable for dynamic linking).
125. COMPLETE USER-SPACE MAP:
0x5555555000-0x5555556000 r-xp .text (contains PLT)
0x5555556000-0x5555557000 r--p .rodata (read-only)
0x5555557000-0x5555558000 rw-p .data (contains GOT)
126. WHY: Map memory layout. Cannot explain section permissions without first showing ELF sections and process mappings.

127. objdump -d test | grep -A10 -B5 0x1050
128. What are as exact PLT instructions for open?
129. readelf -x .text test | grep -A5 -B5 50
130. What are as raw bytes at PLT entry?
131. readelf -r test | grep open
132. What is as relocation type for open symbol?
133. MATH: R_X86_64_JUMP_SLOT = 7. Type indicates PLT needs jump slot resolution at runtime.
134. readelf -x .got.plt test
135. How many bytes does each GOT entry occupy?
136. ANSWER: 8 bytes (64-bit pointer).
137. WHY: Examine PLT structure. Cannot explain indirection mechanism without first showing relocation types and entry sizes.

138. gcc -c test.c -o test.o
139. nm test.o
140. What does nm show for open symbol?
141. readelf -s test.o
142. What symbol table exists in object file?
143. MATH: Object file has .symtab but .dynsym is empty. Static linking vs dynamic linking difference.
144. gcc -static test.c -o test_static
145. ldd test_static
146. What libraries does static binary need?
147. objdump -d test_static | grep -A3 -B3 call
148. What address does static version call directly?
149. MATH: Static linking embeds open address directly. No PLT, no GOT, no indirection.
150. readelf -r test_static
151. Are there any relocations?
152. ANSWER: None - fully resolved at link time.
153. WHY: Compare static vs dynamic. Cannot explain linking choices without first showing relocations disappear in static build.

154. gdb test
155. break main
156. run
157. printf "filename=%p argv[1]\n", (char *)0x7fffffffeba0
158. What is as stack address of your filename string?
159. x/20s 0x7fffffffeba0
160. What characters are stored at that stack address?
161. MATH: Stack grows down. Arguments at higher addresses than local variables. argv[1] at 0x7fffffffeba0.
162. info frame
163. What is as current frame pointer value?
164. info registers rsp rbp
165. What are as stack and frame pointer values?
166. MATH: RBP points to frame base, RSP points to stack top. RBP > RSP for valid stack frame.
167. STACK LAYOUT:
[higher addresses]
0x7fffffffeba0: "somefile\0" (argv[1])
0x7fffffffeba8: pointer to argv[1]
0x7fffffffebb8: other argv entries
0x7fffffffdc80: environment variables
[stack grows down ↓]
0x7fffffffdc50: RBP (frame pointer)
0x7fffffffdc40: RSP (stack pointer)
168. WHY: Understand stack layout. Cannot explain argument passing without first showing actual stack addresses and relationships.