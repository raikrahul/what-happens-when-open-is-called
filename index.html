<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>The Open() Pre-Syscall Odyssey</title>
    <style>
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            line-height: 1.2;
            margin: 0;
            padding: 20px;
            font-size: 11px;
        }
        
        .book {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
        }
        
        .column {
            flex: 1;
            padding: 0 20px;
            border-right: 1px solid #333;
        }
        
        .column:last-child {
            border-right: none;
        }
        
        .chapter {
            margin-bottom: 40px;
            text-align: justify;
        }
        
        .address {
            color: #f00;
            font-weight: bold;
        }
        
        code {
            color: #fff;
            background: transparent;
            padding: 1px 2px;
        }
        
        .page-number {
            text-align: center;
            color: #666;
            margin-top: 20px;
            font-size: 10px;
        }
        
        .break {
            page-break-before: always;
        }
    </style>
</head>
<body>
    <div class="book">
        <div class="column">
            
            <div class="chapter">
                You write int main() { open("somefile", O_RDWR); } in test.c. The compiler has no idea where open() lives. It creates an object file with a placeholder. The call instruction contains zeros: e8 00 00 00 00. The linker will fill these zeros later. You run readelf -r test.o and see open listed as UND. UND means undefined. The compiler cheated - it promised the linker would fix this.
            </div>
            
            <div class="chapter">
                The linker takes your object file and creates an executable. It finds the PLT section and writes a stub. The call instruction becomes call <span class="address">0x1050</span>. This is not the real open(). This is a trampoline. The PLT stub says jmp QWORD PTR [rip+<span class="address">0x2f76</span>]. Your CPU calculates next instruction address + offset = <span class="address">0x555555557fd0</span>. This is the GOT slot. The GOT contains the real address of open() in libc. But who wrote that address?
            </div>
            
            <div class="chapter">
                The dynamic linker runs when your program starts. It sees you need libc.so.6. It maps this library at a random address thanks to ASLR. Let's say it maps at <span class="address">0x7ffff7c00000</span>. The linker reads libc's symbol table. It finds open() at offset <span class="address">0x11b150</span>. It adds these: <span class="address">0x7ffff7c00000</span> + <span class="address">0x11b150</span> = <span class="address">0x7ffff7d1b150</span>. It writes this address to the GOT slot at <span class="address">0x555555557fd0</span>. Now the indirect jump will work.
            </div>
            
            <div class="chapter">
                You run the program multiple times. Each time the address changes. First run: open() at <span class="address">0x7ffff7d1b150</span>. Second run: open() at <span class="address">0x7ffff7e2a000</span>. Third run: open() at <span class="address">0x7ffff7c48000</span>. But your compiled binary still contains call <span class="address">0x1050</span>. How does this work? The PLT is a fixed address in your binary. The GOT is in your writable data segment. The dynamic linker rewrites the GOT each time. Your code never changes.
            </div>
            
            <div class="chapter">
                The CPU jumps to <span class="address">0x7ffff7d1b150</span>. This is __libc_open64. The function pushes rbp and saves registers. It checks your flags: O_RDWR = 2. The code says and $<span class="address">0x40</span>,%r10d. This checks if O_CREAT is set. 2 & 64 = 0. The zero flag is set. The jne instruction does not jump. It falls through to the fast path. No mode argument is needed.
            </div>
            
            <div class="page-number">1</div>
            
        </div>
        
        <div class="column">
            
            <div class="chapter">
                The function checks __libc_single_threaded. The assembly says cmpb $0x0,<span class="address">0xefeae</span>(%rip). This reads a global variable. In your program it contains 1. 1 != 0, so the zero flag is not set. The je instruction does not jump. It continues to the cancellation-safe path. Even though you are single-threaded, libc takes the careful route.
            </div>
            
            <div class="chapter">
                The register shuffle begins. The kernel expects openat(), not open(). The arguments must move. First: mov $<span class="address">0xffffff9c</span>,%edi. This is -100 in two's complement. AT_FDCWD is defined as -100 in the kernel headers. Second: mov %r12,%rsi. Your filename pointer moves to RSI. Third: mov %ebx,%edx. Your O_RDWR flag moves to RDX. Fourth: mov $<span class="address">0x101</span>,%eax. This is 257 decimal, the syscall number for openat.
            </div>
            
            <div class="chapter">
                The final register state before syscall: RAX contains 257, RDI contains <span class="address">0xffffff9c</span> (-100), RSI contains the filename address, RDX contains 2. The CPU will execute the syscall instruction next. It will save the next instruction address to RCX, save flags to R11, and jump to the kernel entry point at MSR_LSTAR. Your journey in user space is complete.
            </div>
            
            <div class="chapter">
                The complete address chain: main calls <span class="address">0x1050</span> (PLT). PLT jumps to [RIP+<span class="address">0x2f76</span>] = <span class="address">0x555555557fd0</span> (GOT). GOT contains <span class="address">0x7ffff7d1b150</span> (libc). libc base is <span class="address">0x7ffff7c00000</span> + offset <span class="address">0x11b150</span> = <span class="address">0x7ffff7d1b150</span>. Four memory reads, two address calculations, one register indirection.
            </div>
            
            <div class="chapter">
                The VMA mappings show your binary layout: <span class="address">0x5555555000</span>-<span class="address">0x5555556000</span> r-xp for code, <span class="address">0x5555556000</span>-<span class="address">0x5555557000</span> rw-p for data. The PLT lives in the executable segment. The GOT lives in the data segment. libc maps at <span class="address">0x7ffff7c00000</span>-<span class="address">0x7ffff7db0000</span> r-xp for code, <span class="address">0x7ffff7db0000</span>-<span class="address">0x7ffff7dd0000</span> rw-p for data. All permissions match their usage.
            </div>
            
            <div class="chapter">
                The prediction exercises: If gcc -static, there is no PLT/GOT. The call instruction contains the absolute address of open(). If AT_FDCWD becomes -200, the hex value changes to <span class="address">0xffffff38</span>. If GOT corruption occurs at <span class="address">0x41414141</span>, the CPU jumps to invalid memory and segmentation faults. If ASLR disabled, addresses stay constant across runs. If O_CREAT added, the flag value becomes <span class="address">0x41</span> (65 decimal) and R10 gets the mode argument.
            </div>
            
            <div class="page-number">2</div>
            
        </div>
    </div>
</body>
</html>