<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Axiomatic Open() Journey</title>
    <style>
        body {
            background: #000;
            color: #fff;
            font-family: 'Courier New', monospace;
            line-height: 1.2;
            margin: 0;
            padding: 20px;
            font-size: 11px;
        }
        
        .book {
            display: flex;
            max-width: 1600px;
            margin: 0 auto;
        }
        
        .column {
            flex: 1;
            padding: 0 20px;
            border-right: 1px solid #333;
        }
        
        .column:last-child {
            border-right: none;
        }
        
        .axiom {
            margin-bottom: 30px;
        }
        
        .address {
            color: #f00;
            font-weight: bold;
        }
        
        .box {
            font-family: monospace;
            background: #111;
            padding: 10px;
            border: 1px solid #333;
            margin: 10px 0;
            white-space: pre;
        }
        
        .calculation {
            margin: 15px 0;
            padding: 10px;
            background: #1a1a1a;
        }
    </style>
</head>
<body>
    <div class="book">
        <div class="column">
            
            <div class="axiom">
                1. Write int main() { open("somefile", O_RDWR); } in test.c
                2. Run: gcc -c test.c -o test.o
                3. Run: readelf -r test.o | grep open
                4. Observe: UND means undefined. Symbol table shows no address.
                5. The compiler cannot know open() location at compile time.
                6. Run: objdump -d test.o | grep call
                7. Instruction bytes: e8 00 00 00 00
                8. Call offset = 0x00000000 = placeholder
                9. Question: Can CPU jump to address <span class="address">0x00000000</span>? No.
            </div>
            
            <div class="axiom">
                10. Run: gcc test.o -o test
                11. Run: objdump -d test | grep -A1 -B1 call
                12. Call target = <span class="address">0x1050</span>
                13. Next instruction = <span class="address">0x1055</span>
                14. PLT jump instruction: jmp QWORD PTR [rip+<span class="address">0x2f76</span>]
                15. RIP-relative calculation: <span class="address">0x1055</span> + <span class="address">0x2f76</span> = <span class="address">0x3fcb</span>
                16. GOT slot = <span class="address">0x3fcb</span> after load address adjustment
                17. Who writes value to <span class="address">0x3fcb</span>? Not compiler, not linker.
            </div>
            
            <div class="axiom">
                18. Run: ldd test
                19. libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (<span class="address">0x7ffff7e00000</span>)
                20. libc base address = <span class="address">0x7ffff7e00000</span>
                21. Run: readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep -E "open.*FUNC"
                22. __libc_open64 at <span class="address">0x000000000011b150</span>
                23. Real open() address = <span class="address">0x7ffff7e00000</span> + <span class="address">0x11b150</span> = <span class="address">0x7ffff7f1b150</span>
                24. Who calculates this sum? Dynamic linker at program startup.
            </div>
            
            <div class="box">
25. BEFORE program execution:
   GOT[<span class="address">0x3fcb</span>] = 0x00000000 (empty)
   libc_base = ? (not mapped)
   open_address = ?

AFTER dynamic linker runs:
   GOT[<span class="address">0x3fcb</span>] = <span class="address">0x7ffff7f1b150</span>
   libc_base = <span class="address">0x7ffff7e00000</span>
   open_address = <span class="address">0x7ffff7f1b150</span>
            </div>
            
            <div class="axiom">
                26. Run: gdb test
                27. break main
                28. run
                29. p open
                30. Address = <span class="address">0x7ffff7f1b150</span>
                31. quit
                32. run again
                33. p open
                34. Address = <span class="address">0x7ffff7d0a000</span>
                35. run again
                36. p open
                37. Address = <span class="address">0x7ffff7f58000</span>
                38. Addresses change. Binary unchanged. How?
            </div>
            
            <div class="axiom">
                39. PLT address is constant = <span class="address">0x1050</span>
                40. GOT address is constant = <span class="address">0x3fcb</span>
                41. GOT content changes each run.
                42. CPU jumps: main → PLT → GOT → libc
                43. PLT is in your binary (fixed).
                44. GOT is in your data segment (writable).
                45. Dynamic linker updates GOT at load time.
            </div>
            
        </div>
        
        <div class="column">
            
            <div class="axiom">
                46. Run: gdb test
                47. break open
                48. run
                49. info registers
                50. RDI = <span class="address">0x555555556004</span> (filename pointer)
                51. RSI = 0x00000002 (O_RDWR)
                52. RDX = 0x00000000
                53. Check: man 2 open
                54. O_RDONLY = 0x00000000
                55. O_WRONLY = 0x00000001  
                56. O_RDWR = 0x00000002
                57. Your RSI = 0x00000002 ✓
            </div>
            
            <div class="calculation">
58. O_RDWR binary: 0000 0010
59. O_CREAT value: 0x00000040 (0100 0000)
60. AND operation: 0000 0010 & 0100 0000 = 0000 0000
61. Result = 0. Zero flag set in CPU.
62. Assembly: and $<span class="address">0x40</span>,%r10d
63. jne instruction follows. Zero flag = true → no jump.
            </div>
            
            <div class="axiom">
                64. Continue in gdb: stepi
                65. cmpb $0x0,<span class="address">0xefeae</span>(%rip)
                66. Memory location = <span class="address">0x7ffff7d0b040</span>
                67. x/1bx <span class="address">0x7ffff7d0b040</span>
                68. Value = 0x01
                69. cmpb compares 0x00 with 0x01
                70. Result: 0x01 != 0x00 → zero flag = false
                71. je instruction does NOT jump.
            </div>
            
            <div class="axiom">
                72. Continue: stepi
                73. mov $<span class="address">0xffffff9c</span>,%edi
                74. Two's complement calculation: ~99 + 1
                75. 99 decimal = 0x63
                76. ~0x63 = 0x9C
                77. 0x9C + 1 = 0x9D
                78. Extend to 32-bit: <span class="address">0xFFFFFF9C</span>
                79. Result: -100 decimal ✓
            </div>
            
            <div class="axiom">
                80. Check: grep -r "AT_FDCWD" /usr/include/
                81. File: /usr/include/x86_64-linux-gnu/fcntl.h
                82. Line: #define AT_FDCWD -100
                83. EDI now holds -100 ✓
                84. mov %r12,%rsi (filename pointer)
                85. mov %ebx,%edx (flags = 2)
                86. mov $<span class="address">0x101</span>,%eax
                87. <span class="address">0x101</span> hex = 257 decimal
                88. grep "257" /usr/include/x86_64-linux-gnu/asm/unistd_64.h
                89. Line: #define __NR_openat 257
                90. RAX = 257 ✓
            </div>
            
            <div class="box">
91. FINAL REGISTER STATE:
   RAX = 257 (sys_openat)
   RDI = -100 (AT_FDCWD)  
   RSI = <span class="address">0x555555556004</span> (filename)
   RDX = 2 (O_RDWR flags)

ADDRESS CHAIN:
main call → PLT[<span class="address">0x1050</span>]
PLT jump → GOT[<span class="address">0x3fcb</span>]  
GOT value → <span class="address">0x7ffff7f1b150</span> (__libc_open64)
            </div>
            
            <div class="axiom">
                92. Check: cat /proc/self/maps | grep test
                93. Range1: <span class="address">0x5555555000</span>-<span class="address">0x5555556000</span> r-xp (code)
                94. Range2: <span class="address">0x5555556000</span>-<span class="address">0x5555557000</span> r--p (rodata)
                95. Range3: <span class="address">0x5555557000</span>-<span class="address">0x5555558000</span> rw-p (data)
                96. PLT at <span class="address">0x1050</span> ∈ Range1 ✓
                97. GOT at <span class="address">0x3fcb</span> ∈ Range3 ✓
            </div>
            
            <div class="axiom">
                98. Check: cat /proc/self/maps | grep libc
                99. libc range: <span class="address">0x7ffff7e00000</span>-<span class="address">0x7ffff7fc0000</span>
                100. __libc_open64 = <span class="address">0x7ffff7f1b150</span>
                101. Verify: <span class="address">0x7ffff7e00000</span> ≤ <span class="address">0x7ffff7f1b150</span> < <span class="address">0x7ffff7fc0000</span> ✓
                102. Permissions: r-xp (executable, readable)
            </div>
            
            <div class="axiom">
                103. Next instruction: syscall
                104. CPU saves RCX = return address
                105. CPU saves R11 = flags register
                106. CPU reads MSR_LSTAR register
                107. CPU jumps to kernel entry point
                108. Ring changes from 3 to 0
                109. Your program execution pauses
                110. User space journey complete
            </div>
            
        </div>
    </div>
</body>
</html>