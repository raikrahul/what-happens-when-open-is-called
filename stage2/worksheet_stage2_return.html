<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Stage 2 Return: Axiomatic Worksheet</title>
    <style>
        body {
            background: #ffffff;
            color: #000000;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.7;
            padding: 40px;
            max-width: 900px;
            margin: 0 auto;
        }
        pre {
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
        }
        .blank {
            display: inline-block;
            min-width: 150px;
            border-bottom: 1px solid #000;
            color: #fff;
        }
    </style>
</head>
<body>
<pre>
================================================================================
WORKSHEET STAGE 2 RETURN: FD_INSTALL TRACING
================================================================================

This worksheet builds everything from scratch. 
Each question uses only what came before it.
No external knowledge required.

================================================================================
LINE 001: COUNTING
================================================================================

AXIOM: We start with the natural numbers.

0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, ...

EXERCISE 1:
Count how many numbers from 0 to 9: __________
Count how many numbers from 0 to 10: __________

================================================================================
LINE 002: MEMORY AS BOXES
================================================================================

AXIOM: Computer memory is like a row of boxes.
Each box has:
- A NUMBER (its address)
- CONTENTS (what's inside)

DRAWING:
  Box 0: [__________]
  Box 1: [__________]
  Box 2: [__________]
  Box 3: [__________]

EXERCISE 2:
If Box 0 contains 42, write: Box[0] = 42
If Box 1 contains 55, write: Box[1] = 55

Fill in:
  Box[0] = __________
  Box[1] = __________

================================================================================
LINE 003: BYTES
================================================================================

DEFINITION: A byte is 8 bits.

DERIVATION:
  Each bit can be 0 or 1
  With 8 bits: 2 × 2 × 2 × 2 × 2 × 2 × 2 × 2 = 2^8 = 256
  So one byte can hold 256 different values (0 to 255)

EXERCISE 3:
Maximum value in one byte: __________
Number of values in one byte: __________

================================================================================
LINE 004: MEMORY ADDRESSES
================================================================================

AXIOM: Each byte has an address.

EXAMPLE:
  Address 0: [byte 0]
  Address 1: [byte 1]
  Address 2: [byte 2]
  ...

NOTATION: MEM[0] means "the byte at address 0"

EXERCISE 4:
If MEM[100] = 42 and MEM[101] = 55:
  MEM[100] = __________
  MEM[101] = __________

================================================================================
LINE 005: POINTERS
================================================================================

DEFINITION: A pointer is a variable that holds a memory address.

DERIVATION:
  Let p = 100
  This means p holds the address 100
  Therefore: MEM[p] = MEM[100] = 42

NOTATION: 
  *p means "the value at address p"
  &x means "the address of x"

EXERCISE 5:
If p = 100 and MEM[100] = 42:
  p = __________
  *p = __________

================================================================================
LINE 006: WHAT IS A PROGRAM?
================================================================================

AXIOM: A program is a sequence of instructions.

DERIVATION:
  1. The CPU reads instructions one by one
  2. Each instruction does something simple
  3. Many simple instructions = complex behavior

EXAMPLE INSTRUCTIONS:
  ADD 5, 3 → result is 8
  STORE 8, 100 → MEM[100] = 8
  LOAD 100 → read MEM[100]

================================================================================
LINE 007: WHAT IS AN OS?
================================================================================

DEFINITION: An Operating System (OS) is a program that manages resources.

RESOURCES MANAGED:
  - CPU time (who runs when)
  - Memory (who gets which bytes)
  - Files (data on disk)

DERIVATION:
  Multiple programs want to run at once
  The OS decides: Program A runs for 10ms, then Program B
  The OS protects: Program A cannot read Program B's memory

================================================================================
LINE 008: USER SPACE VS KERNEL SPACE
================================================================================

AXIOM: Memory is divided into two regions.

REGION 1: User Space
  - Where normal programs run
  - Restricted access
  - Cannot touch hardware directly

REGION 2: Kernel Space
  - Where the OS runs
  - Full access
  - Can touch hardware

DERIVATION:
  If programs could touch hardware directly:
  - Program A could erase Program B's files
  - Program A could crash the computer
  Therefore: Need separation for safety

================================================================================
LINE 009: SYSTEM CALLS
================================================================================

DEFINITION: A system call is the gateway from user space to kernel space.

DERIVATION from LINE 008:
  User programs need to ask the OS for services
  But user programs cannot enter kernel space directly
  Therefore: Need a special instruction that crosses the boundary
  This instruction = system call

EXAMPLE FLOW:
  1. User program: "I want to open a file"
  2. System call instruction executes
  3. CPU switches to kernel mode
  4. Kernel code runs
  5. Kernel returns to user mode
  6. User program continues

================================================================================
LINE 010: THE OPEN SYSTEM CALL
================================================================================

DEFINITION: open() asks the kernel to access a file.

INPUTS (what we give):
  1. Filename: a sequence of characters (string)
  2. Flags: numbers that say what we want to do

OUTPUT (what we get back):
  1. File descriptor: a small integer
  2. Or: an error code (negative number)

DERIVATION:
  Why return a number instead of the filename?
  - Numbers are smaller (4 bytes vs many bytes)
  - Numbers are faster to compare
  - Numbers fit in CPU registers

================================================================================
LINE 011: FILE DESCRIPTORS
================================================================================

DEFINITION: A file descriptor is an integer index into a table.

DERIVATION from LINE 010:
  The kernel maintains a table of open files
  Each entry in the table is a pointer to file information
  The index into this table = file descriptor

STANDARD DESCRIPTORS (always present):
  fd = 0: Standard Input (keyboard)
  fd = 1: Standard Output (screen)
  fd = 2: Standard Error (screen for errors)

USER OPENED FILES:
  fd = 3: First file you open
  fd = 4: Second file you open
  fd = 5: Third file you open

EXERCISE 11:
If a program opens one file:
  What fd does it get? __________
  
Why? Because 0, 1, 2 are already taken.
Next available = 3.

================================================================================
LINE 012: WHERE IS THE TABLE?
================================================================================

AXIOM: The kernel keeps per-process information.

DERIVATION from LINE 011:
  Each running program = one process
  Each process needs its own file table
  Otherwise: Process A could read Process B's files!

STRUCTURE (nested like Russian dolls):
  Process
    └── Files Information
          └── File Descriptor Table
                └── Array of Pointers

NOTATION:
  current = the currently running process
  current->files = its file information
  current->files->fdt = its file descriptor table
  current->files->fdt->fd = array of file pointers
  current->files->fdt->fd[3] = pointer to file #3's info

================================================================================
LINE 013: WHAT IS FD_INSTALL?
================================================================================

DEFINITION: fd_install is a kernel function.

FUNCTION SIGNATURE:
  void fd_install(int fd, struct file *file)

DERIVATION from LINE 012:
  This function takes:
  1. fd: which slot in the table (an integer)
  2. file: pointer to the file structure
  
  And does:
  current->files->fdt->fd[fd] = file

EXERCISE 13:
If fd_install(3, 0xffff8881000) runs:
  What gets stored where?
  
  current->files->fdt->fd[__________] = __________
  
  Answer: current->files->fdt->fd[3] = 0xffff8881000

================================================================================
LINE 014: WHAT ARE REGISTERS?
================================================================================

DEFINITION: Registers are storage inside the CPU.

AXIOM: The x86_64 CPU has named registers.

IMPORTANT REGISTERS FOR SYSTEM CALLS:
  RDI - holds 1st argument
  RSI - holds 2nd argument
  RDX - holds 3rd argument
  RAX - holds return value

DERIVATION:
  Why use registers?
  - They are very fast (inside CPU)
  - No memory access needed
  - Perfect for passing arguments

EXERCISE 14:
For fd_install(fd, file):
  Which register holds fd? __________
  Which register holds file? __________
  
  Answer: RDI holds fd, RSI holds file

================================================================================
LINE 015: x86_64 CALLING CONVENTION
================================================================================

AXIOM: There is a rule for how arguments are passed.

RULE (System V AMD64 ABI):
  Argument 1 → RDI
  Argument 2 → RSI
  Argument 3 → RDX
  Argument 4 → RCX
  Argument 5 → R8
  Argument 6 → R9
  Return value → RAX

DERIVATION from LINE 014:
  Everyone agrees on this rule
  Compiler knows: put 1st arg in RDI
  Kernel knows: look in RDI for 1st arg
  Therefore: They can communicate

EXERCISE 15:
If fd_install(3, 0xffff...) is called:
  RDI = __________
  RSI = __________
  
  Answer: RDI = 3, RSI = 0xffff...

================================================================================
LINE 016: KPROBES
================================================================================

DEFINITION: A kprobe is a way to watch kernel functions.

DERIVATION:
  We want to see what fd_install does
  We cannot modify the kernel source code
  Therefore: Need a mechanism to attach our code
  Kprobe = "run my code when fd_install runs"

TYPES:
  Entry probe: Runs when function starts
  Return probe: Runs when function ends

WE USE: Entry probe on fd_install

================================================================================
LINE 017: THE ENTRY HANDLER
================================================================================

DEFINITION: The entry handler is our code that runs first.

WHAT IT RECEIVES:
  A pointer to the registers (pt_regs)

WHAT IT CAN DO:
  Read any register value
  Print the values
  Continue to the real function

CODE:
  static int entry_handler(struct kprobe *p, struct pt_regs *regs) {
    int fd = (int)regs->di;  // Read RDI
    struct file *file = (struct file *)regs->si;  // Read RSI
    printk("fd = %d, file = %px\n", fd, file);
    return 0;
  }

EXERCISE 17:
What does regs->di contain? __________
What does regs->si contain? __________

Answer: regs->di = RDI = fd, regs->si = RSI = file pointer

================================================================================
LINE 018: CASTING IN C
================================================================================

DEFINITION: Casting tells the compiler to change types.

EXAMPLE:
  regs->di is unsigned long (64 bits)
  (int)regs->di means: take lower 32 bits as int

DERIVATION:
  fd is an int (4 bytes = 32 bits)
  RDI is 8 bytes (64 bits)
  We only need the lower 4 bytes
  Casting extracts them

EXERCISE 18:
If regs->di = 0x0000000000000003:
  (int)regs->di = __________
  
  Answer: 3 (just the lower 32 bits)

================================================================================
LINE 019: HEXADECIMAL NUMBERS
================================================================================

DEFINITION: Hex is base-16 (digits 0-9, A-F).

DERIVATION from counting:
  Decimal (base 10): 0,1,2,3,4,5,6,7,8,9,10,11,...
  Hex (base 16): 0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,10,11,...

NOTATION: Prefix with 0x
  0x0A = 10 in decimal
  0xFF = 255 in decimal
  0x100 = 256 in decimal

EXERCISE 19:
0x03 in decimal: __________
0x0A in decimal: __________
0x10 in decimal: __________

================================================================================
LINE 020: KERNEL ADDRESSES
================================================================================

AXIOM: Kernel addresses start with high bits set.

On x86_64 Linux:
  User addresses: 0x0000000000000000 to 0x00007FFFFFFFFFFF
  Kernel addresses: 0xFFFF800000000000 to 0xFFFFFFFFFFFFFFFF

DERIVATION from LINE 008:
  Must distinguish user from kernel
  Simple rule: Check first hex digit
  0x0000... = user
  0xFFFF... = kernel

EXERCISE 20:
0x00007FFF12345678 is: [ ] user [ ] kernel
0xFFFF888100234000 is: [ ] user [ ] kernel

================================================================================
LINE 021: THE COMPLETE TRACE
================================================================================

PUTTING IT ALL TOGETHER:

STEP 1: User runs: open("somefile", O_RDWR)

STEP 2: Kernel processes through many functions
        Eventually calls: fd_install(3, file_ptr)

STEP 3: Our kprobe entry handler runs:
        - Reads regs->di → gets 3
        - Reads regs->si → gets 0xffff888100234000
        - Prints: "fd_install: fd=3, file=0xffff..."

STEP 4: Real fd_install runs:
        - current->files->fdt->fd[3] = file_ptr
        - File descriptor 3 now points to the file

STEP 5: Return to user:
        - User gets fd = 3
        - Can now use read(3, buf, size)

EXERCISE 21:
What value is in current->files->fdt->fd[3] after fd_install?
Answer: __________

================================================================================
LINE 022: VERIFICATION STEPS
================================================================================

DO: Load the driver
  cd drivers/return_fd && make && sudo insmod trace_fd.ko

DO: Run the test program
  ./minimal_open

DO: Check the output
  dmesg | tail -5

OBSERVE: You should see
  fd_install: fd=3
  file=0xffff...
  task=minimal_open

FILL IN THE BLANKS:
  fd = __________
  file pointer = __________
  task name = __________

================================================================================
LINE 023: CONCLUSION
================================================================================

WHAT WE LEARNED (derived from axioms):

1. Memory has addresses and values
2. Pointers hold addresses
3. OS runs in kernel space, programs in user space
4. System calls cross from user to kernel
5. open() returns a file descriptor (integer)
6. fd_install puts the file pointer in the table
7. We can trace this with kprobes
8. Arguments are in RDI (fd) and RSI (file)

Every concept was built from previous lines.
No external knowledge was used.

================================================================================
ANSWERS (CHECK AFTER COMPLETING)
================================================================================

EXERCISE 1: 10 numbers (0-9), 11 numbers (0-10)
EXERCISE 3: 255, 256
EXERCISE 5: p=100, *p=42
EXERCISE 11: 3
EXERCISE 13: fd[3] = 0xffff8881000
EXERCISE 14: RDI, RSI
EXERCISE 15: RDI=3, RSI=0xffff...
EXERCISE 17: fd, file pointer
EXERCISE 18: 3
EXERCISE 19: 3, 10, 16
EXERCISE 20: user, kernel
EXERCISE 21: file_ptr (0xffff...)

================================================================================
END OF WORKSHEET
================================================================================
</pre>
</body>
</html>
