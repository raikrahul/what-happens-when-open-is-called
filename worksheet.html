<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Worksheet: open() Axiomatic Derivation</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 14px;
      line-height: 1.6;
      padding: 20px;
      margin: 0;
    }

    pre {
      margin: 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>

<body>
  <pre>
================================================================================
AXIOMATIC WORKSHEET: WHAT HAPPENS WHEN open() IS CALLED
================================================================================
Each step: DO something, SEE output, DERIVE knowledge, ASK why.
No magic. No new things without derivation.

================================================================================
STEP 01: THE SOURCE CODE
================================================================================

DO:   View your source file.
RUN:  cat minimal_open.c

You will see:
    #include &lt;fcntl.h&gt;
    int main() {
        int fd = open("somefile", O_RDWR);
        return 0;
    }

OBSERVE:
    Line 1: #include &lt;fcntl.h&gt;
    Line 3: open("somefile", O_RDWR)

INQUIRY:
    Q1: What is O_RDWR? A number? A string? Magic?
    Q2: What is fcntl.h? Where is it?
    Q3: What is open()? Where is it defined?

AXIOM: At this stage, we have TEXT. Nothing more.


================================================================================
STEP 02: FIND THE HEADER
================================================================================

DO:   Find where O_RDWR is defined.
RUN:  grep -r "define O_RDWR" /usr/include | head -1

OUTPUT: /usr/include/asm-generic/fcntl.h:#define O_RDWR 00000002

OBSERVE:
    O_RDWR = 00000002
    The leading 0 means OCTAL (base 8).

MATH (Octal to Decimal):
    00000002 in octal
    = 0*8^7 + 0*8^6 + 0*8^5 + 0*8^4 + 0*8^3 + 0*8^2 + 0*8^1 + 2*8^0
    = 0 + 0 + 0 + 0 + 0 + 0 + 0 + 2
    = 2

CONCLUSION: O_RDWR = 2 (decimal)

INQUIRY:
    Q: Why octal? A: Historical. Unix permissions use octal (chmod 755).


================================================================================
STEP 03: PREPROCESSING
================================================================================

DO:   Run the preprocessor to see what the compiler actually gets.
RUN:  gcc -E minimal_open.c | tail -5

OUTPUT (filtered):
    int fd = open("somefile", 02);

OBSERVE:
    O_RDWR has been REPLACED with 02.
    The preprocessor does TEXT SUBSTITUTION only.

MATH (Verification):
    We predicted O_RDWR = 2.
    Preprocessor output shows 02 (octal) = 2 (decimal).
    VERIFIED.

AXIOM: Preprocessor replaces macros with their values. No code generated yet.


================================================================================
STEP 04: COMPILATION TO OBJECT FILE
================================================================================

DO:   Compile to object file (not executable).
RUN:  gcc -c minimal_open.c -o minimal_open.o

DO:   Examine the call instruction.
RUN:  objdump -d minimal_open.o | grep -A2 "call"

OUTPUT:
    20:   e8 00 00 00 00    call   25 &lt;main+0x25&gt;

OBSERVE:
    Address 0x20: opcode e8 (CALL instruction)
    Address 0x21: operand 00 00 00 00 (ZEROS!)

INQUIRY:
    Q: Why are there ZEROS where the address should be?
    A: The compiler does not know where open() will be.
       open() is in libc, which is not linked yet.

MATH (Instruction Layout):
    e8 = opcode (1 byte)
    00 00 00 00 = operand (4 bytes, displacement)
    Total = 5 bytes
    Next instruction at 0x20 + 5 = 0x25

AXIOM: Object file has PLACEHOLDERS (zeros) for external functions.


================================================================================
STEP 05: RELOCATION ENTRIES
================================================================================

DO:   Find the relocation entry that tells the linker what to fix.
RUN:  readelf -r minimal_open.o | grep open

OUTPUT:
    000000000021  000500000004 R_X86_64_PLT32    0000000000000000 open - 4

OBSERVE:
    Offset = 0x21 (where to patch)
    Type = R_X86_64_PLT32 (patch with PLT address)
    Symbol = open (what to find)
    Addend = -4 (subtract 4 from the result)

INQUIRY:
    Q: Why offset 0x21, not 0x20?
    A: 0x20 is the opcode (e8). 0x21 is the operand (the zeros to fill).

    Q: Why addend -4?
    A: The CPU calculates: target = RIP + displacement.
       RIP points to NEXT instruction (0x25).
       Patch location is 0x21.
       RIP = 0x21 + 4 = 0x25.
       So displacement must account for this: subtract 4.

MATH (Addend Derivation):
    Patch location = 0x21
    Next RIP after fetch = 0x21 + 4 = 0x25
    Difference = 4
    Therefore addend = -4

AXIOM: Relocation entry = {offset, type, symbol, addend}. It is a FORMULA.


================================================================================
STEP 06: LINKING - SECTION LAYOUT
================================================================================

DO:   Link the object file to create an executable.
RUN:  gcc minimal_open.o -o minimal_open

DO:   Examine the section layout.
RUN:  readelf -S minimal_open | grep -E "(plt|got|text)"

OUTPUT:
    [13] .plt      PROGBITS  0000000000001020
    [14] .plt.got  PROGBITS  0000000000001040
    [15] .plt.sec  PROGBITS  0000000000001050
    [16] .text     PROGBITS  0000000000001060
    [23] .got      PROGBITS  0000000000003fb8

OBSERVE:
    .plt     at 0x1020   (Procedure Linkage Table - CODE)
    .plt.sec at 0x1050   (PLT Security section - CODE)
    .text    at 0x1060   (Your code - CODE)
    .got     at 0x3fb8   (Global Offset Table - DATA)

INQUIRY:
    Q: PLT comes BEFORE GOT in memory. Why?
    A: Code sections (.plt, .text) are grouped together.
       Data sections (.got) are grouped separately.
       This is for memory protection (code = read+execute, data = read+write).

MATH (Address Spacing):
    .plt to .plt.sec:  0x1050 - 0x1020 = 0x30 = 48 bytes
    .plt.sec to .text: 0x1060 - 0x1050 = 0x10 = 16 bytes

AXIOM: Linker creates PLT (code) and GOT (data). PLT is at lower address.


================================================================================
STEP 07: WHAT IS PLT?
================================================================================

PLT = Procedure Linkage Table.

DO:   Look at the PLT entry for open.
RUN:  objdump -d minimal_open | grep -A3 "open@plt"

OUTPUT:
    0000000000001050 &lt;open@plt&gt;:
    1050:   f3 0f 1e fa       endbr64
    1054:   ff 25 76 2f 00 00 jmp    *0x2f76(%rip)

OBSERVE:
    Address 0x1050: open@plt
    Instruction at 0x1054: jmp *0x2f76(%rip)
    This is an INDIRECT jump - jump to address STORED somewhere.

INQUIRY:
    Q: What is 0x2f76(%rip)?
    A: RIP-relative addressing. Add 0x2f76 to the next RIP.

MATH (Calculate Jump Target):
    Instruction at 0x1054, length = 6 bytes (ff 25 + 4 bytes displacement)
    Next RIP = 0x1054 + 6 = 0x105a
    Target = 0x105a + 0x2f76 = _____

    0x105a in decimal: 4186
    0x2f76 in decimal: 12150
    Sum: 4186 + 12150 = 16336
    16336 in hex: 0x3fd0

CONCLUSION: PLT jumps to address stored at 0x3fd0.

AXIOM: PLT is CODE. It jumps to an address stored in GOT.


================================================================================
STEP 08: WHAT IS GOT?
================================================================================

GOT = Global Offset Table.

DO:   Find the GOT entry for open.
RUN:  readelf -r minimal_open | grep "open"

OUTPUT:
    000000003fd0  000400000007 R_X86_64_JUMP_SLO 0000000000000000 open@GLIBC

OBSERVE:
    Address 0x3fd0 is the GOT slot for open.
    This matches our calculation in STEP 07!

DO:   Read the current value in GOT.
RUN:  objdump -s -j .got minimal_open | grep 3fd0

OUTPUT:
    3fd0 30100000 00000000

OBSERVE:
    Value at 0x3fd0 = 0x0000000000001030 (little-endian)

INQUIRY:
    Q: What is 0x1030?
    A: Let's find out in the next step.

MATH (Little-Endian to Value):
    Bytes: 30 10 00 00 00 00 00 00
    Read right-to-left: 00 00 00 00 00 00 10 30
    Result: 0x1030

AXIOM: GOT is DATA. It stores addresses. Initially points to resolver stub.


================================================================================
STEP 09: THE RESOLVER STUB
================================================================================

DO:   Find what is at 0x1030.
RUN:  objdump -d minimal_open | grep -A3 "1030:"

OUTPUT:
    1030:   f3 0f 1e fa         endbr64
    1034:   68 00 00 00 00      push   $0x0
    1039:   f2 e9 e1 ff ff ff   jmp    1020 &lt;_init+0x20&gt;

OBSERVE:
    0x1030 is a STUB in .plt section.
    It pushes 0 (index) and jumps to 0x1020 (resolver).

INQUIRY:
    Q: Why push 0?
    A: Index 0 means "first function in relocation table" = open.

    Q: What is at 0x1020?
    A: The PLT header - calls the dynamic linker resolver.

MATH (The Lazy Binding Loop):
    1. Code calls 0x1050 (open@plt)
    2. 0x1050 jumps to *0x3fd0
    3. 0x3fd0 contains 0x1030
    4. 0x1030 pushes index, jumps to 0x1020
    5. 0x1020 calls resolver
    6. Resolver finds real open() in libc
    7. Resolver writes real address to 0x3fd0
    8. Next call goes directly to libc (fast!)

AXIOM: First call is SLOW (resolver). Subsequent calls are FAST (direct).


================================================================================
STEP 10: THE CALL INSTRUCTION PATCH
================================================================================

DO:   Find the patched call instruction.
RUN:  objdump -d minimal_open | grep "call.*open"

OUTPUT:
    1169:   e8 e2 fe ff ff      call   1050 &lt;open@plt&gt;

OBSERVE:
    Address 0x1169: the call instruction
    Operand: e2 fe ff ff (was 00 00 00 00 in object file!)
    Target: 0x1050 (open@plt)

MATH (Verify the Displacement):
    Displacement bytes: e2 fe ff ff (little-endian)
    As 32-bit signed: 0xfffffee2

    Is this negative? Check sign bit.
    0xfffffee2 in binary starts with 1... so YES, negative.

    Two's Complement to Decimal:
    Invert:  0x0000011d
    Add 1:   0x0000011e
    0x11e = 286 decimal
    So displacement = -286

    Verify: next_RIP + displacement = target
    next_RIP = 0x1169 + 5 = 0x116e
    0x116e + (-286) = 0x116e - 0x11e = 0x1050

    CORRECT!

AXIOM: Linker computed displacement = target - next_RIP = 0x1050 - 0x116e = -286.


================================================================================
STEP 11: RUNTIME - LIBC LOADING
================================================================================

DO:   Run the program under GDB and check GOT before/after.
RUN:  gdb -batch -ex "break main" -ex "run" -ex "x/gx 0x3fd0" ./minimal_open

OUTPUT (before first call):
    0x3fd0: 0x0000555555555030

OBSERVE:
    GOT still points to stub (now with ASLR base added).

DO:   Step past the open() call and check GOT again.
RUN:  gdb -batch -ex "break *main+50" -ex "run" -ex "x/gx 0x3fd0" ./minimal_open

OUTPUT (after first call):
    0x3fd0: 0x00007ffff7d1b150

OBSERVE:
    GOT now points to LIBC! The resolver patched it.

MATH (ASLR Address Calculation):
    libc base (example): 0x7ffff7c00000
    open offset in libc: 0x11b150
    open runtime addr:   0x7ffff7c00000 + 0x11b150 = 0x7ffff7d1b150

DO:   Verify the offset.
RUN:  readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep " open@"

OUTPUT:
    000000000011b150 ... open@@GLIBC_2.2.5

CONFIRMED: Offset 0x11b150 matches!

AXIOM: Runtime address = ASLR_base + fixed_offset.


================================================================================
STEP 12: INSIDE LIBC - open() TO openat()
================================================================================

DO:   Disassemble the libc open function.
RUN:  gdb -batch -ex "disas open" ./minimal_open | head -20

OBSERVE (key instructions):
    mov    $0xffffff9c,%edi    ; AT_FDCWD = -100
    mov    $0x101,%eax         ; syscall 257 = openat
    syscall

INQUIRY:
    Q: You called open(file, flags). But kernel receives openat(dir, file, flags, mode)?
    A: YES! libc transforms open() to openat() internally.

MATH (AT_FDCWD = -100):
    -100 in two's complement (32-bit):
    100 decimal = 0x64
    Invert: 0xffffff9b
    Add 1:  0xffffff9c

DO:   Verify syscall number.
RUN:  grep 257 /usr/include/asm/unistd_64.h

OUTPUT:
    #define __NR_openat 257

CONFIRMED: Syscall 257 is openat.

AXIOM: libc::open() calls kernel::openat(AT_FDCWD, path, flags, 0).


================================================================================
STEP 13: FAILURE PREDICTIONS
================================================================================

Now you understand the chain. Predict what breaks.

FAILURE 1: File does not exist
    PREDICTION: open() returns -1, errno = 2 (ENOENT)
    VERIFY: strace ./minimal_open 2>&amp;1 | grep openat

FAILURE 2: No permission
    PREDICTION: open() returns -1, errno = 13 (EACCES)
    VERIFY: chmod 000 somefile; strace ./minimal_open

FAILURE 3: Too many open files
    PREDICTION: open() returns -1, errno = 24 (EMFILE)
    VERIFY: ulimit -n 10; run program opening 20 files

MATH (errno values):
    RUN: grep -E "ENOENT|EACCES|EMFILE" /usr/include/asm-generic/errno-base.h
    OUTPUT:
        #define ENOENT  2
        #define EACCES 13
        #define EMFILE 24


================================================================================
STEP 14: THE COMPLETE CHAIN
================================================================================

SOURCE:     open("somefile", O_RDWR)
                |
PREPROCESS: open("somefile", 02)
                |
COMPILE:    call 0x00000000 (zeros)
                |
ASSEMBLE:   reloc entry: offset=0x21, symbol=open, addend=-4
                |
LINK:       call 0x1050 (open@plt)
            PLT at 0x1050: jmp *0x3fd0
            GOT at 0x3fd0: 0x1030 (stub)
                |
RUNTIME:    First call:
                PLT -> GOT -> stub -> resolver -> libc
                Resolver patches GOT: 0x3fd0 = 0x7ffff7d1b150
                |
            Subsequent calls:
                PLT -> GOT -> libc (direct!)
                |
LIBC:       Transform: open(file, flags) -> openat(-100, file, flags, 0)
            Register setup: RDI=-100, RSI=file, RDX=flags, RAX=257
            syscall
                |
KERNEL:     sys_openat() executes
            Returns file descriptor or error

================================================================================
END OF WORKSHEET
================================================================================
Every step derived from previous step.
Every number verified by command.
No magic. No new things without derivation.
</pre>
</body>

</html>