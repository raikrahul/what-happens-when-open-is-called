<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Worksheet: open() Complete with Axiom Comments</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
      padding: 20px 40px;
      min-width: 1200px;
      width: max-content;
    }

    pre {
      margin: 0;
      white-space: pre;
      overflow-x: visible;
    }

    .cmd {
      font-style: italic;
    }

    .ptr {
      font-weight: bold;
    }

    .cmt {
      color: #666;
    }
  </style>
</head>

<body>
  <pre>
========================================================================================================================
PART A: PLT-GOT ARITHMETIC
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
A00. AXIOM: WHAT IS GOT?
------------------------------------------------------------------------------------------------------------------------

Before we calculate GOT addresses, we must define GOT.                         <span class="cmt">// Why do we need this? Without definition, GOT is magic.</span>

GOT = Global Offset Table.                                                     <span class="cmt">// Definition: A table of pointers.</span>
Purpose: Store addresses of external functions.                                <span class="cmt">// Why? Because addresses are unknown at compile time.</span>
Location: In the .got section of the executable.                               <span class="cmt">// Where did this come from? From ELF specification.</span>
Entry Size: 8 bytes (64-bit pointer).                                          <span class="cmt">// Why 8? Because x86_64 uses 64-bit addresses = 8 bytes.</span>

How do we find GOT location?                                                   <span class="cmt">// This is the key question.</span>

<span class="cmd">$ readelf -S minimal_open | grep got</span>                                            <span class="cmt">// Command: read ELF Section headers, filter for "got".</span>

Output will show: .got at address <span class="ptr">0x____</span>                                        <span class="cmt">// Fill this blank from YOUR machine's output.</span>

This address is our AXIOM. We did not calculate it.                            <span class="cmt">// Critical: This is observed, not derived.</span>
The linker decided this address. We accept it as given.                        <span class="cmt">// Why? Because the linker is the authority here.</span>

------------------------------------------------------------------------------------------------------------------------
A01. GOT ADDRESS EQUATION
------------------------------------------------------------------------------------------------------------------------

Now we derive the GOT address for a specific function.                         <span class="cmt">// What are we doing? Calculating where "open" is stored.</span>

Step 1: Identify GOT base address.                                             <span class="cmt">// Where does this come from? Section A00 above.</span>
got_base = <span class="ptr">0x3fb8</span>                                                              <span class="cmt">// AXIOM: Observed from readelf -S. Not calculated.</span>

Step 2: Identify function index.                                               <span class="cmt">// How do we know the index? We must derive it.</span>

<span class="cmd">$ readelf -r minimal_open | grep "rela.plt" -A5</span>                                 <span class="cmt">// Command: read relocation table for PLT.</span>

Output shows entries in order:                                                 <span class="cmt">// The ORDER is the index assignment.</span>
  Entry 0: open                                                                <span class="cmt">// First entry = index 0. WHY? Because arrays start at 0.</span>

But wait - GOT has reserved entries!                                           <span class="cmt">// NEW THING ALERT: Where did "reserved" come from?</span>

GOT[0] = address of _DYNAMIC                                                   <span class="cmt">// AXIOM: ELF ABI specification says so.</span>
GOT[1] = address of link_map                                                   <span class="cmt">// AXIOM: ELF ABI specification says so.</span>
GOT[2] = address of _dl_runtime_resolve                                        <span class="cmt">// AXIOM: ELF ABI specification says so.</span>

Therefore: First function slot = index 3.                                      <span class="cmt">// DERIVATION: 0,1,2 reserved. open is first. 0+3=3.</span>

Step 3: Calculate GOT address for open.                                        <span class="cmt">// Now we have all inputs. Let's compute.</span>

Equation: got_addr = got_base + (index * entry_size)                           <span class="cmt">// Where did this equation come from? Array indexing math.</span>

got_addr = 0x3fb8 + (3 * 8)                                                    <span class="cmt">// Substitution: base=0x3fb8, index=3, size=8.</span>

0x3fb8 in decimal:                                                             <span class="cmt">// WHY convert? To do the arithmetic properly.</span>
  3 * 4096 = 12288                                                             <span class="cmt">// 0x3 * 0x1000</span>
  f * 256  = 15 * 256 = 3840                                                   <span class="cmt">// 0xf * 0x100</span>
  b * 16   = 11 * 16 = 176                                                     <span class="cmt">// 0xb * 0x10</span>
  8 * 1    = 8                                                                 <span class="cmt">// 0x8 * 0x1</span>
  sum      = 12288 + 3840 + 176 + 8 = <span class="ptr">16312</span>                                     <span class="cmt">// CALCULATION: add them up.</span>

3 * 8 = 24                                                                     <span class="cmt">// CALCULATION: index * size.</span>

16312 + 24 = <span class="ptr">16336</span>                                                             <span class="cmt">// CALCULATION: base + offset.</span>

16336 in hex:                                                                  <span class="cmt">// WHY convert back? To verify against tools.</span>
  16336 / 16 = 1021 remainder 0                                                <span class="cmt">// Last digit: 0</span>
  1021 / 16  = 63 remainder 13 = d                                             <span class="cmt">// Next digit: d</span>
  63 / 16    = 3 remainder 15 = f                                              <span class="cmt">// Next digit: f</span>
  3 / 16     = 0 remainder 3                                                   <span class="cmt">// First digit: 3</span>
  Result     = <span class="ptr">0x3fd0</span>                                                          <span class="cmt">// DERIVED: GOT address for open.</span>

Step 4: VERIFY.                                                                <span class="cmt">// Never trust your calculation. Check against tool.</span>

<span class="cmd">$ readelf -r minimal_open | grep open</span>                                          <span class="cmt">// Command: find open in relocation table.</span>

Output shows: 0x3fd0 ... open                                                  <span class="cmt">// Does it match? If not, which step was wrong?</span>

------------------------------------------------------------------------------------------------------------------------
A02. WHERE DID THE DISPLACEMENT COME FROM?
------------------------------------------------------------------------------------------------------------------------

The PLT instruction contains a displacement. We must derive it.                <span class="cmt">// What are we doing? Reverse-engineering the jmp.</span>

<span class="cmd">$ objdump -d minimal_open | grep -A3 "open@plt"</span>                                 <span class="cmt">// Command: disassemble, find open's PLT entry.</span>

Output:                                                                        <span class="cmt">// Read carefully. Every byte matters.</span>
  1050: f3 0f 1e fa    endbr64                                                 <span class="cmt">// What is this? Security instruction. 4 bytes. Ignore for now.</span>
  1054: ff 25 76 2f 00 00    jmp *0x2f76(%rip)                                  <span class="cmt">// THIS is the jump. Bytes: ff 25 76 2f 00 00.</span>

Let's decode the jmp instruction:                                              <span class="cmt">// Why? To understand how CPU calculates the target.</span>

ff 25 = opcode for "jmp *displacement(%rip)"                                   <span class="cmt">// AXIOM: Intel manual says so. Not derived.</span>
76 2f 00 00 = displacement in little-endian                                    <span class="cmt">// What is little-endian? Low byte first. So 76, 2f, 00, 00.</span>

Convert to big-endian (human readable):                                        <span class="cmt">// Reverse the bytes.</span>
  76 2f 00 00 -> 00 00 2f 76                                                   <span class="cmt">// CALCULATION: swap byte order.</span>
  = 0x00002f76                                                                 <span class="cmt">// RESULT: displacement is 0x2f76.</span>

Now: what is %rip at this point?                                               <span class="cmt">// CRITICAL: RIP points to NEXT instruction, not current.</span>

jmp instruction at 0x1054.                                                     <span class="cmt">// AXIOM: observed from objdump.</span>
jmp instruction is 6 bytes.                                                    <span class="cmt">// AXIOM: ff 25 XX XX XX XX = 6 bytes.</span>
RIP = 0x1054 + 6 = 0x105a.                                                     <span class="cmt">// CALCULATION: instruction_addr + instruction_length.</span>

GOT address = RIP + displacement                                               <span class="cmt">// AXIOM: how RIP-relative addressing works.</span>
            = 0x105a + 0x2f76                                                  <span class="cmt">// Substitution.</span>

0x105a in decimal:                                                             <span class="cmt">// Convert for addition.</span>
  1 * 4096 = 4096                                                              <span class="cmt">// 0x1 * 0x1000</span>
  0 * 256  = 0                                                                 <span class="cmt">// 0x0 * 0x100</span>
  5 * 16   = 80                                                                <span class="cmt">// 0x5 * 0x10</span>
  a * 1    = 10                                                                <span class="cmt">// 0xa * 0x1</span>
  sum      = 4096 + 0 + 80 + 10 = <span class="ptr">4186</span>                                          <span class="cmt">// CALCULATION.</span>

0x2f76 in decimal:                                                             <span class="cmt">// Convert displacement.</span>
  2 * 4096 = 8192                                                              <span class="cmt">// 0x2 * 0x1000</span>
  f * 256  = 15 * 256 = 3840                                                   <span class="cmt">// 0xf * 0x100</span>
  7 * 16   = 112                                                               <span class="cmt">// 0x7 * 0x10</span>
  6 * 1    = 6                                                                 <span class="cmt">// 0x6 * 0x1</span>
  sum      = 8192 + 3840 + 112 + 6 = <span class="ptr">12150</span>                                       <span class="cmt">// CALCULATION.</span>

4186 + 12150 = <span class="ptr">16336</span>                                                            <span class="cmt">// CALCULATION: RIP + displacement.</span>

16336 in hex = <span class="ptr">0x3fd0</span>                                                           <span class="cmt">// We calculated this in A01!</span>

VERIFICATION: GOT address matches A01? ___                                     <span class="cmt">// Circle: YES/NO. If NO, find the error.</span>

------------------------------------------------------------------------------------------------------------------------
A03. CALL DISPLACEMENT (TWO'S COMPLEMENT)
------------------------------------------------------------------------------------------------------------------------

The call instruction has bytes: e8 e2 fe ff ff                                 <span class="cmt">// AXIOM: observed from objdump.</span>
We must derive where these bytes came from.                                    <span class="cmt">// What are we doing? Proving the linker's math.</span>

<span class="cmd">$ objdump -d minimal_open | grep "call.*open"</span>                                   <span class="cmt">// Command: find the call instruction.</span>

Output: 1169: e8 e2 fe ff ff    call 1050 &lt;open@plt&gt;                            <span class="cmt">// call at 0x1169, target 0x1050.</span>

Step 1: Understand the call instruction format.                                <span class="cmt">// Why? To know how to calculate displacement.</span>

e8 = opcode for "call rel32"                                                   <span class="cmt">// AXIOM: Intel manual. "rel32" means 32-bit relative.</span>
e2 fe ff ff = displacement in little-endian                                    <span class="cmt">// These 4 bytes ARE the displacement.</span>

Step 2: Calculate what RIP will be.                                            <span class="cmt">// CRITICAL: RIP points to instruction AFTER the call.</span>

call instruction at 0x1169.                                                    <span class="cmt">// AXIOM: observed.</span>
call instruction is 5 bytes.                                                   <span class="cmt">// AXIOM: e8 + 4 bytes = 5.</span>
RIP = 0x1169 + 5 = 0x116e.                                                     <span class="cmt">// CALCULATION.</span>

Step 3: Calculate required displacement.                                       <span class="cmt">// What value must the linker write?</span>

Equation: target = RIP + displacement                                          <span class="cmt">// AXIOM: how relative calls work.</span>
Therefore: displacement = target - RIP                                         <span class="cmt">// Rearrange algebra.</span>
         = 0x1050 - 0x116e                                                     <span class="cmt">// Substitution.</span>

0x1050 in decimal:                                                             <span class="cmt">// Convert.</span>
  1*4096 + 0*256 + 5*16 + 0*1 = 4096 + 80 = <span class="ptr">4176</span>                               <span class="cmt">// CALCULATION.</span>

0x116e in decimal:                                                             <span class="cmt">// Convert.</span>
  1*4096 + 1*256 + 6*16 + 14*1 = 4096 + 256 + 96 + 14 = <span class="ptr">4462</span>                    <span class="cmt">// CALCULATION.</span>

4176 - 4462 = <span class="ptr">-286</span>                                                              <span class="cmt">// CALCULATION: negative! This is expected.</span>

Step 4: Convert -286 to two's complement (32-bit).                             <span class="cmt">// Why? Because x86 uses 2's complement for signed numbers.</span>

286 in binary:                                                                 <span class="cmt">// First convert positive value.</span>
  286 = 256 + 16 + 8 + 4 + 2 = 2^8 + 2^4 + 2^3 + 2^2 + 2^1                     <span class="cmt">// CALCULATION: decompose.</span>
  = 0000 0000 0000 0000 0000 0001 0001 1110                                    <span class="cmt">// RESULT: 32-bit binary.</span>

Invert all bits:                                                               <span class="cmt">// Step 1 of 2's complement.</span>
  = 1111 1111 1111 1111 1111 1110 1110 0001                                    <span class="cmt">// CALCULATION: flip 0<->1.</span>

Add 1:                                                                         <span class="cmt">// Step 2 of 2's complement.</span>
  = 1111 1111 1111 1111 1111 1110 1110 0010                                    <span class="cmt">// CALCULATION: binary addition.</span>

Convert to hex:                                                                <span class="cmt">// Group into nibbles (4 bits each).</span>
  1111 = f, 1111 = f, 1111 = f, 1111 = f                                       <span class="cmt">// First 16 bits = ffff.</span>
  1111 = f, 1110 = e, 1110 = e, 0010 = 2                                       <span class="cmt">// Last 16 bits = fee2.</span>
  = <span class="ptr">0xfffffee2</span>                                                                 <span class="cmt">// RESULT: -286 in 32-bit 2's complement.</span>

Step 5: Convert to little-endian.                                              <span class="cmt">// Why? x86 stores multi-byte values low-byte-first.</span>

0xfffffee2 as bytes: ff ff fe e2                                               <span class="cmt">// Big-endian (human order).</span>
Reverse: e2 fe ff ff                                                           <span class="cmt">// Little-endian (machine order).</span>

Step 6: VERIFY.                                                                <span class="cmt">// Does our calculation match the binary?</span>

<span class="cmd">$ xxd -s 0x116a -l 4 minimal_open</span>                                              <span class="cmt">// Command: dump 4 bytes starting at displacement field.</span>

Output should be: e2 fe ff ff                                                  <span class="cmt">// Compare to our calculation.</span>
Match? ___                                                                     <span class="cmt">// Circle: YES/NO.</span>

========================================================================================================================
PART B: WHAT IS PLT? (MISSING SECTION - MUST DEFINE BEFORE USING)
========================================================================================================================

Before we used "open@plt" we never defined what PLT is.                        <span class="cmt">// NEW THING ALERT: We introduced PLT without definition.</span>

PLT = Procedure Linkage Table.                                                 <span class="cmt">// Definition: A table of small code stubs.</span>
Purpose: Redirect function calls to actual addresses.                          <span class="cmt">// Why? Because actual addresses are unknown until runtime.</span>
Location: In the .plt and .plt.sec sections.                                   <span class="cmt">// Where did this come from? ELF specification.</span>
Entry Size: 16 bytes per function.                                             <span class="cmt">// Why 16? Architecture decision. Each stub is 16 bytes.</span>

Relationship to GOT:                                                           <span class="cmt">// How do they connect?</span>
  PLT entry N jumps to address stored in GOT entry N.                          <span class="cmt">// AXIOM: This is how lazy binding works.</span>

Why two tables?                                                                <span class="cmt">// Good question.</span>
  PLT = CODE (instructions that jump).                                         <span class="cmt">// PLT is executable.</span>
  GOT = DATA (addresses to jump to).                                           <span class="cmt">// GOT is writable.</span>
  Separation = security (W^X: writable XOR executable).                        <span class="cmt">// Why? To prevent code injection attacks.</span>

========================================================================================================================
PART C: METAMORPHOSIS - PHASE BY PHASE
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
C01. SOURCE CODE (Phase 0)
------------------------------------------------------------------------------------------------------------------------

<span class="cmd">$ cat minimal_open.c</span>                                                           <span class="cmt">// Command: view source.</span>

Content:                                                                       <span class="cmt">// What do we observe?</span>
  #include &lt;fcntl.h&gt;                                                           <span class="cmt">// Header file. Provides O_RDWR. Where is it? /usr/include.</span>
  int main() {                                                                 <span class="cmt">// Entry point. Where did "main" come from? C standard.</span>
    int fd = open("somefile", O_RDWR);                                         <span class="cmt">// Function call. What is "open"? A TOKEN at this point.</span>
  }                                                                            <span class="cmt">// End. Simple program.</span>

Key observation: "open" is just text.                                          <span class="cmt">// The CPU cannot execute text. It needs addresses.</span>

------------------------------------------------------------------------------------------------------------------------
C02. PREPROCESSOR (Phase 1)
------------------------------------------------------------------------------------------------------------------------

What happens: cpp replaces #include and #define.                               <span class="cmt">// What are we tracking? The token "open".</span>

<span class="cmd">$ gcc -E minimal_open.c | grep -E "(open|O_RDWR)"</span>                               <span class="cmt">// Command: preprocess, search for our tokens.</span>

Observation 1: O_RDWR becomes a number.                                        <span class="cmt">// Was O_RDWR defined? Where? In fcntl.h.</span>

<span class="cmd">$ grep -r "O_RDWR" /usr/include/asm-generic/fcntl.h</span>                            <span class="cmt">// Command: find the definition.</span>

Output: #define O_RDWR 02                                                      <span class="cmt">// AXIOM: This is the definition. 02 is OCTAL.</span>

Octal 02 to decimal:                                                           <span class="cmt">// Why convert? To use in calculations.</span>
  0 * 8 + 2 * 1 = <span class="ptr">2</span>                                                             <span class="cmt">// CALCULATION: base-8 to base-10.</span>

Observation 2: "open" is UNCHANGED.                                            <span class="cmt">// Did preprocessor resolve "open"? NO.</span>

Why not? Because open is not a macro.                                          <span class="cmt">// There is no #define open. Check it.</span>

<span class="cmd">$ gcc -E minimal_open.c | grep "#define open"</span>                                   <span class="cmt">// Command: search for open macro.</span>

Output: (empty)                                                                <span class="cmt">// No macro. "open" passes through unchanged.</span>

------------------------------------------------------------------------------------------------------------------------
C03. COMPILATION (Phase 2)
------------------------------------------------------------------------------------------------------------------------

What happens: cc1 translates C to assembly.                                    <span class="cmt">// What are we tracking? Still "open".</span>

<span class="cmd">$ gcc -S minimal_open.c -o minimal_open.s</span>                                      <span class="cmt">// Command: compile to assembly.</span>
<span class="cmd">$ grep open minimal_open.s</span>                                                     <span class="cmt">// Command: find "open" in assembly.</span>

Output: call open@PLT                                                          <span class="cmt">// "open" became "open@PLT". What does @PLT mean?</span>

@PLT = "resolve this through the Procedure Linkage Table"                      <span class="cmt">// AXIOM: Compiler convention for external functions.</span>

Why @PLT? Because compiler knows open is EXTERNAL.                             <span class="cmt">// How does it know? Because there's no definition in this file.</span>

------------------------------------------------------------------------------------------------------------------------
C04. ASSEMBLY (Phase 3)
------------------------------------------------------------------------------------------------------------------------

What happens: as translates assembly to object code.                           <span class="cmt">// What are we tracking? The call instruction.</span>

<span class="cmd">$ gcc -c minimal_open.c -o minimal_open.o</span>                                      <span class="cmt">// Command: assemble to object file.</span>
<span class="cmd">$ objdump -d minimal_open.o | grep call</span>                                        <span class="cmt">// Command: disassemble, find call.</span>

Output: 20: e8 00 00 00 00    call 25 &lt;main+0x25&gt;                               <span class="cmt">// Displacement is 00 00 00 00. WHY ZEROS?</span>

Because assembler does not know where open will be.                            <span class="cmt">// It's external. Address unknown.</span>
Assembler writes PLACEHOLDER (zeros).                                          <span class="cmt">// The linker will fill this in.</span>

But how will linker know what to fill?                                         <span class="cmt">// Good question.</span>

Assembler creates RELOCATION ENTRY:                                            <span class="cmt">// A note for the linker.</span>

<span class="cmd">$ readelf -r minimal_open.o | grep open</span>                                        <span class="cmt">// Command: read relocation table.</span>

Output: 0x21 R_X86_64_PLT32 open - 4                                           <span class="cmt">// AXIOM: This is the relocation record.</span>

Let's decode each field:                                                       <span class="cmt">// Don't skip any field.</span>
  0x21 = offset where patch goes.                                              <span class="cmt">// Why 0x21? Because e8 is at 0x20, displacement at 0x21.</span>
  R_X86_64_PLT32 = relocation type.                                            <span class="cmt">// What does it mean? "32-bit PLT-relative patch".</span>
  open = symbol name.                                                          <span class="cmt">// What to look up.</span>
  -4 = addend.                                                                 <span class="cmt">// Why -4? See Part A03 for explanation.</span>

------------------------------------------------------------------------------------------------------------------------
C05. LINKING (Phase 4)
------------------------------------------------------------------------------------------------------------------------

What happens: ld combines objects, resolves symbols.                            <span class="cmt">// What are we tracking? The zeros becoming real bytes.</span>

<span class="cmd">$ gcc minimal_open.o -o minimal_open</span>                                           <span class="cmt">// Command: link.</span>
<span class="cmd">$ objdump -d minimal_open | grep "call.*open"</span>                                  <span class="cmt">// Command: find the call now.</span>

Output: 1169: e8 e2 fe ff ff    call 1050 &lt;open@plt&gt;                            <span class="cmt">// Zeros became e2 fe ff ff. This is our Part A03.</span>

Linker did:                                                                    <span class="cmt">// Reconstruct linker's actions.</span>
  1. Created .plt section with stub for open.                                  <span class="cmt">// Why? To enable lazy binding.</span>
  2. Created .got entry for open.                                              <span class="cmt">// Why? To store the runtime address.</span>
  3. Calculated displacement to PLT: 0x1050 - 0x116e = -286.                   <span class="cmt">// We verified this in Part A03.</span>
  4. Wrote -286 as 2's complement little-endian: e2 fe ff ff.                  <span class="cmt">// We calculated this in Part A03.</span>

------------------------------------------------------------------------------------------------------------------------
C06. RUNTIME RESOLUTION (Phase 5)
------------------------------------------------------------------------------------------------------------------------

What happens: Dynamic linker resolves actual address.                           <span class="cmt">// What are we tracking? GOT entry value.</span>

Initially, GOT[open] points to a stub.                                         <span class="cmt">// Why? Lazy binding - don't resolve until needed.</span>

<span class="cmd">$ xxd -s 0x2fd0 -l 8 minimal_open</span>                                              <span class="cmt">// Command: dump GOT entry (file offset = 0x3fd0 - 0x1000).</span>

Output: 30 10 00 00 00 00 00 00                                                <span class="cmt">// Little-endian. Reverse: 00 00 00 00 00 00 10 30 = 0x1030.</span>

0x1030 is the PLT stub address.                                                <span class="cmt">// VERIFY: objdump shows stub at 0x1030.</span>

After first call, resolver patches GOT:                                        <span class="cmt">// What happens at runtime?</span>

<span class="cmd">$ gdb ./minimal_open</span>                                                           <span class="cmt">// Command: debug.</span>
(gdb) break *0x1169                                                            <span class="cmt">// Break at call.</span>
(gdb) run                                                                      <span class="cmt">// Execute.</span>
(gdb) x/gx 0x555555557fd0                                                      <span class="cmt">// Examine GOT (ASLR base + 0x3fd0).</span>

BEFORE: 0x555555555030                                                         <span class="cmt">// Points to stub (base + 0x1030).</span>

(gdb) stepi (repeat until past resolver)                                       <span class="cmt">// Step through.</span>
(gdb) x/gx 0x555555557fd0                                                      <span class="cmt">// Examine again.</span>

AFTER: 0x7ffff7d1b150                                                          <span class="cmt">// Points to libc! Resolver patched it.</span>

========================================================================================================================
PART D: LIBC INTERNALS - WHAT HAPPENS INSIDE OPEN?
========================================================================================================================

------------------------------------------------------------------------------------------------------------------------
D01. FINDING OPEN IN LIBC
------------------------------------------------------------------------------------------------------------------------

We know GOT gets 0x7ffff7d1b150. But what IS at that address?                  <span class="cmt">// Let's verify it's really open.</span>

<span class="cmd">$ nm -D /lib/x86_64-linux-gnu/libc.so.6 | grep -w open</span>                         <span class="cmt">// Command: list dynamic symbols.</span>

Output: 000000000011b150 W open@@GLIBC_2.2.5                                    <span class="cmt">// open is at offset 0x11b150 in libc.</span>

libc base + offset = runtime address:                                          <span class="cmt">// Let's verify the math.</span>
  base   = 0x7ffff7c00000                                                      <span class="cmt">// From gdb info proc mappings.</span>
  offset = 0x11b150                                                            <span class="cmt">// From nm.</span>
  sum    = ?                                                                   <span class="cmt">// We must calculate.</span>

0x7ffff7c00000 + 0x11b150:                                                     <span class="cmt">// This is a 48-bit addition.</span>

Easier: 0x7ffff7c00000 + 0x11b150                                              <span class="cmt">// Just add the lower bits.</span>
      = 0x7ffff7c00000 + 0x00011b150                                           <span class="cmt">// Align.</span>
      = 0x7ffff7d1b150                                                         <span class="cmt">// RESULT. Matches GDB!</span>

------------------------------------------------------------------------------------------------------------------------
D02. OPEN IS AN ALIAS
------------------------------------------------------------------------------------------------------------------------

Something strange in the nm output: W means WEAK symbol.                       <span class="cmt">// What does that mean?</span>

<span class="cmd">$ readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep 11b150</span>                     <span class="cmt">// Command: find all symbols at that address.</span>

Output:                                                                        <span class="cmt">// Multiple symbols at SAME address!</span>
  11b150 ... __open_nocancel                                                   <span class="cmt">// This is the REAL function.</span>
  11b150 ... open@@GLIBC_2.2.5                                                 <span class="cmt">// This is an ALIAS (weak).</span>
  11b150 ... __libc_open64                                                     <span class="cmt">// Another alias.</span>

DERIVATION: open = __open_nocancel = __libc_open64.                            <span class="cmt">// They are ALL the same function.</span>

------------------------------------------------------------------------------------------------------------------------
D03. REGISTER SHUFFLE (OPEN -> OPENAT)
------------------------------------------------------------------------------------------------------------------------

You called: open(file, flags)                                                  <span class="cmt">// Two arguments.</span>
Kernel has: openat(dirfd, file, flags, mode)                                   <span class="cmt">// Four arguments.</span>

Libc TRANSFORMS your call:                                                     <span class="cmt">// Why? Because kernel uses openat syscall.</span>

BEFORE (your call):                                                            <span class="cmt">// ABI: arguments in rdi, rsi, rdx, ...</span>
  RDI = 0x555555556004 (pointer to "somefile")                                 <span class="cmt">// Arg 1: filename.</span>
  RSI = 2 (O_RDWR)                                                             <span class="cmt">// Arg 2: flags.</span>

AFTER (libc transforms):                                                       <span class="cmt">// Libc shuffles registers.</span>
  RDI = 0xffffff9c (AT_FDCWD)                                                  <span class="cmt">// Arg 1: "current directory".</span>
  RSI = 0x555555556004 (pointer to "somefile")                                 <span class="cmt">// Arg 2: filename (was RDI).</span>
  RDX = 2 (O_RDWR)                                                             <span class="cmt">// Arg 3: flags (was RSI).</span>
  R10 = 0 (mode, unused because no O_CREAT)                                    <span class="cmt">// Arg 4: mode.</span>
  RAX = 257 (openat syscall number)                                            <span class="cmt">// Syscall number.</span>

What is AT_FDCWD?                                                              <span class="cmt">// NEW THING. Must define.</span>

AT_FDCWD = -100                                                                <span class="cmt">// AXIOM: defined in fcntl.h.</span>
Meaning: "use current working directory"                                       <span class="cmt">// Why? So openat with AT_FDCWD behaves like open.</span>

-100 in 32-bit two's complement:                                               <span class="cmt">// We must derive this.</span>
  100 decimal = 64 + 32 + 4 = 0110 0100 binary                                 <span class="cmt">// CALCULATION.</span>
  invert:       1001 1011                                                      <span class="cmt">// CALCULATION.</span>
  + 1:          1001 1100                                                      <span class="cmt">// CALCULATION.</span>
  32-bit:       1111 1111 1111 1111 1111 1111 1001 1100                        <span class="cmt">// Sign extend.</span>
  hex:          0xffffff9c                                                     <span class="cmt">// RESULT.</span>

<span class="cmd">$ python3 -c "print(hex(-100 & 0xffffffff))"</span>                                   <span class="cmt">// VERIFY.</span>
Output: 0xffffff9c                                                             <span class="cmt">// Matches.</span>

========================================================================================================================
PART E: FAILURE PREDICTIONS
========================================================================================================================

For each error, we calculate the EXACT consequence.                            <span class="cmt">// Not just "it crashes". HOW does it crash?</span>

------------------------------------------------------------------------------------------------------------------------
E01. LINKER DISPLACEMENT OFF BY 1
------------------------------------------------------------------------------------------------------------------------

Correct: e2 fe ff ff                                                           <span class="cmt">// We calculated this.</span>
Wrong:   e3 fe ff ff                                                           <span class="cmt">// What if lowest byte is e3?</span>

Wrong displacement in decimal:                                                 <span class="cmt">// Calculate.</span>
  0xfffffee3 as signed = -285                                                  <span class="cmt">// One less than correct (-286).</span>

Wrong target = 0x116e + (-285) = 0x116e - 285                                  <span class="cmt">// Calculate.</span>
  0x116e = 4462                                                                <span class="cmt">// From earlier.</span>
  4462 - 285 = 4177                                                            <span class="cmt">// CALCULATION.</span>
  4177 in hex = 0x1051                                                         <span class="cmt">// CALCULATION.</span>

Expected target: 0x1050                                                        <span class="cmt">// What we wanted.</span>
Actual target:   0x1051                                                        <span class="cmt">// What CPU jumps to.</span>

What is at 0x1051?                                                             <span class="cmt">// Let's check.</span>

<span class="cmd">$ objdump -d minimal_open | grep "1051"</span>                                        <span class="cmt">// Command.</span>

0x1050 = endbr64 (f3 0f 1e fa) = 4 bytes.                                      <span class="cmt">// Instruction at 0x1050.</span>
0x1051 = middle of endbr64!                                                    <span class="cmt">// This is not a valid instruction start.</span>

Result: CPU tries to decode 0f 1e fa ff as an instruction.                     <span class="cmt">// 0f 1e = NOP or something else?</span>
Likely: Undefined behavior, crash, or wrong execution.                         <span class="cmt">// CATASTROPHIC.</span>

========================================================================================================================
FINAL CHAIN
========================================================================================================================

00 00 00 00 (object file placeholder)
  -> linker calculates displacement
    -> e2 fe ff ff (patched call)
      -> jumps to 0x1050 (open@plt)
        -> jmp *0x2f76(%rip) = jmp *0x3fd0
          -> initially 0x1030 (stub)
            -> resolver runs
              -> finds 0x7ffff7d1b150
                -> patches GOT
                  -> all future calls go to libc

EVERY NUMBER DERIVED. NO MAGIC.                                                <span class="cmt">// Did you follow every step?</span>
</pre>
</body>

</html>