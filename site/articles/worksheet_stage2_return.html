<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return - Kernel Filename Tracing (Copy vs Cache)</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">================================================================================
USER SPACE TEST PROGRAMS (AND WHY THEY EXIST)
================================================================================

Location: https://github.com/raikrahul/what-happens-when-open-is-called/tree/main/kernel/user/stage2

PROGRAM 1: minimal_open.c
```c
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char filename[128];
    time_t now = time(NULL);

    // Forces external allocation (name &gt; inline dentry buffer)
    snprintf(filename, sizeof(filename),
             "test_file_very_long_name_to_force_external_allocation_%ld", now);

    int fd = open(filename, O_RDWR | O_CREAT, 0644);
    printf("fd=%d
", fd);
    sleep(5);  // Delay lets us observe a later cache hit.
    close(fd);
    unlink(filename);
    return 0;
}
```

Key insight: a long name forces external allocation in the dentry name path.

PROGRAM 2: matrix_open.c
```c
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

static void close_if_open(int *fd) {
    if (*fd &gt;= 0) {
        close(*fd);
        *fd = -1;
    }
}

static void drop_caches_if_root(void) {
    int fd;
    if (geteuid() != 0)
        return;
    sync();
    fd = open("/proc/sys/vm/drop_caches", O_WRONLY);
    if (fd &gt;= 0) {
        ssize_t w = write(fd, "2
", 2);
        (void)w;
        close(fd);
    }
}

int main() {
    int f[6];
    char n1[] = "l_e.txt";
    char n2[] = "/tmp/t_e.txt";
    char n3[] = "/tmp/t_m.txt";
    char n4[] = "l_m.txt";
    char n5[] = "/mnt/loopfs/a.txt";

    for (int i = 0; i &lt; 6; i++)
        f[i] = -1;

    close(creat(n1, 0644));
    close(creat(n2, 0644));
    drop_caches_if_root();
    sleep(1);

    f[0] = open(n1, O_RDONLY);
    f[1] = open(n2, O_RDONLY);
    f[2] = open(n3, O_RDONLY);
    f[3] = open(n1, O_RDONLY);
    f[4] = open(n4, O_RDONLY);
    f[5] = open(n5, O_RDONLY);

    close_if_open(&amp;f[0]);
    f[0] = open(n1, O_RDONLY);

    sleep(2);
    close_if_open(&amp;f[0]);
    close_if_open(&amp;f[1]);
    close_if_open(&amp;f[2]);
    close_if_open(&amp;f[3]);
    close_if_open(&amp;f[4]);
    close_if_open(&amp;f[5]);

    unlink(n1);
    unlink(n2);
    close(creat(n1, 0644));
    close(creat(n2, 0644));
    f[0] = open(n1, O_RDONLY);
    f[1] = open(n2, O_RDONLY);

    close_if_open(&amp;f[0]);
    close_if_open(&amp;f[1]);

    drop_caches_if_root();
    sleep(1);
    f[0] = open(n1, O_RDONLY);
    f[1] = open(n2, O_RDONLY);
    close_if_open(&amp;f[0]);
    close_if_open(&amp;f[1]);

    return 0;
}
```

Tests: cache miss, allocation path, negative dentries, cache hit, deletion, eviction, rebuild, basename offset, loopback short name.

================================================================================
WHAT WE'RE TRACING (POINTERS, NOT FEELINGS)
================================================================================

Goal: find where the name is copied, where it is reused, where it is deleted, and where it is evicted.

Minimal facts:
- getname copies the user string into kernel memory
- do_filp_open uses struct filename and its name pointer
- __d_alloc copies qstr-&gt;name into dentry-&gt;d_name.name
- d_lookup returns an existing dentry on cache hit
- __d_add inserts a new dentry into the dcache
- d_delete removes a dentry on unlink
- __dentry_kill reclaims a dentry on drop_caches

Trace points (no bracket labels):
- do_filp_open entry: input filename pointer and string
- d_lookup entry: hash, length, name
- d_lookup return: NULL or dentry name pointer
- __d_alloc entry: copy source pointer
- __d_alloc return: copy destination pointer
- __d_add entry: inserted dentry name pointer
- d_delete entry: deleted dentry name pointer
- __dentry_kill entry: evicted dentry name pointer
- __d_lookup and __d_lookup_rcu: internal lookup path keys

Two chains:
- Allocation path: do_filp_open entry -&gt; d_lookup miss -&gt; __d_alloc -&gt; __d_add -&gt; do_filp_open return
- Cache path: do_filp_open entry -&gt; d_lookup hit -&gt; do_filp_open return

================================================================================
DRIVER NOTE (DO THIS OR YOU WILL SEE NOTHING)
================================================================================

The driver filters by process name:
- Default target is matrix_open.
- For minimal_open, you must load with: target_comm=minimal_open

================================================================================
BUILD AND RUN
================================================================================

Build driver:
cd kernel/drivers/trace_do_filp_open &amp;&amp; make clean &amp;&amp; make

Load driver (choose target):
sudo insmod trace_do_filp_open.ko target_comm=minimal_open
sudo rmmod trace_do_filp_open
sudo insmod trace_do_filp_open.ko target_comm=matrix_open

Log filter (use this for all runs):
sudo dmesg | rg -n "l_e.txt|t_e.txt|t_m.txt|l_m.txt|a.txt|drop_caches|d_lookup entry|d_lookup return|__d_add entry|d_delete entry|__dentry_kill entry|__d_lookup entry|__d_lookup_rcu entry|__d_alloc"

================================================================================
TEST 1: LONG FILENAME (minimal_open)
================================================================================

sudo dmesg -C
./minimal_open
sleep 5
sudo dmesg | rg -n "test_file_very_long_name_to_force_external_allocation"

Record:
- do_filp_open entry pointer = 0x________ | test_file_very_long_name_to_force_external_allocation_XXXX
- d_lookup entry: hash ________ length 64 name test_file_very_long_name_to_force_external_allocation_XXXX
- d_lookup return: NULL
- __d_alloc entry pointer = 0x________
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | test_file_very_long_name_to_force_external_allocation_XXXX
- do_filp_open return pointer = 0x________ | test_file_very_long_name_to_force_external_allocation_XXXX
- cache hit later: d_lookup return pointer = 0x________ | test_file_very_long_name_to_force_external_allocation_XXXX

Checks:
- __d_alloc return == __d_add entry == do_filp_open return
- cache hit pointer equals earlier return pointer

================================================================================
TEST 2: MATRIX (matrix_open)
================================================================================

sudo dmesg -C
sudo ./matrix_open
sleep 3
sudo dmesg | rg -n "l_e.txt|t_e.txt|t_m.txt|l_m.txt|a.txt|drop_caches|d_lookup entry|d_lookup return|__d_add entry|d_delete entry|__dentry_kill entry|__d_alloc"

FILE A (t_e.txt, first open after drop_caches):
- do_filp_open entry pointer = 0x________ | /tmp/t_e.txt
- d_lookup entry hash ________ len 7 name t_e.txt
- d_lookup return: NULL
- __d_alloc entry pointer = 0x________
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | t_e.txt
- do_filp_open return pointer = 0x________ | t_e.txt
- offset check: (entry pointer + 5) == __d_alloc entry pointer

FILE B (t_m.txt, missing):
- do_filp_open entry pointer = 0x________ | /tmp/t_m.txt
- d_lookup return: NULL
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | t_m.txt

FILE C (l_m.txt, missing):
- do_filp_open entry pointer = 0x________ | l_m.txt
- d_lookup return: NULL
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | l_m.txt

FILE D (a.txt, loopback ext2):
- do_filp_open entry pointer = 0x________ | /mnt/loopfs/a.txt
- d_lookup return: NULL
- __d_alloc entry pointer = 0x________
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | a.txt
- do_filp_open return pointer = 0x________ | a.txt
- offset check: (entry pointer + 12) == __d_alloc entry pointer

CACHE HIT (before deletion):
- d_lookup return pointer = 0x________ | l_e.txt
- d_lookup return pointer = 0x________ | t_e.txt

DELETION (unlink):
- d_delete entry = 0x________ | l_e.txt
- d_delete entry = 0x________ | t_e.txt

EVICTION (drop_caches):
- do_filp_open entry/return for /proc/sys/vm/drop_caches
- __dentry_kill entry = 0x________ | l_e.txt
- __dentry_kill entry = 0x________ | t_e.txt

REBUILD (after eviction, t_e.txt):
- d_lookup return: NULL
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | t_e.txt
- do_filp_open return pointer = 0x________ | t_e.txt
- inequality check: rebuild pointer != pre-eviction pointer

POST-EVICTION LOOKUP (l_e.txt):
- __d_lookup_rcu entry: hash ________ length 7 name l_e.txt
- do_filp_open return pointer = 0x________ | l_e.txt
- inequality check: post-eviction pointer != pre-eviction pointer

================================================================================
FIND THE COPY
================================================================================

grep -n "memcpy.*name-&gt;name" /usr/src/linux-headers-$(uname -r)/fs/dcache.c
Line: _____

Code:
memcpy(dname, name-&gt;name, name-&gt;len);

================================================================================
FAILURE MODES
================================================================================

1. No output
   Process name filter mismatch.
   Check target_comm parameter.

2. No d_lookup lines
   Probes not registered.
   Ensure kp_lookup, kp_d_lookup, kp_d_lookup_rcu are registered.

3. Crash on error path
   Dereferencing error pointer.
   Check IS_ERR(f) before deref.

4. Kernel panic
   NULL pointer dereference.
   Check pointers before deref.

5. Module load fails
   Kernel version mismatch.
   make clean &amp;&amp; make

6. Missing kernel headers
   Install linux-headers-$(uname -r)

================================================================================
UNDERSTANDING CHECKLIST
================================================================================

[ ] Driver compiles and loads
[ ] minimal_open shows long filename miss + add + return
[ ] long filename later shows cache hit
[ ] matrix_open shows t_e.txt miss + add + return
[ ] /tmp offset check is 5
[ ] loopfs offset check is 12
[ ] matrix_open shows cache hit before deletion
[ ] matrix_open shows deletion via d_delete
[ ] matrix_open shows eviction via __dentry_kill
[ ] matrix_open shows rebuild for t_e.txt after eviction
[ ] matrix_open shows post-eviction lookup for l_e.txt
[ ] memcpy located in kernel source</pre>
  </div>

</body>

</html>