<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return - Kernel Filename Tracing (Copy vs Cache)</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>window.addEventListener('DOMContentLoaded', () => { if (window.hljs) hljs.highlightAll(); });</script>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    pre code {
      display: block;
      white-space: pre;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">[HOME] ../index.html
Print ../articles/worksheet_stage2_return.html
Stage 1 https://raikrahul.github.io/what-happens-when-open-is-called/stage1.html
Stage 2 Entry https://raikrahul.github.io/what-happens-when-open-is-called/stage2.html
Stage 2 Return (Explanation) https://raikrahul.github.io/what-happens-when-open-is-
called/articles/explanation_stage2_return.html
What we trace and where it lives:
trace_do_filp_open driver: kernel/drivers/trace_do_filp_open/trace_do_filp_open.c
do_filp_open: /usr/src/linux-source-6.8.0/fs/open.c
d_lookup, __d_lookup, __d_lookup_rcu, __d_alloc, __d_add, d_delete, __dentry_kill: /usr/src/linux-source-6.8.0/fs/dcache.c</pre>
<pre><code class="language-text">[do_filp_open entry]   struct filename-&gt;name
└─[d_lookup entry]     qstr-&gt;{name,len,hash}
  ├─[__d_lookup entry] qstr-&gt;{name,len,hash}
  ├─[__d_lookup_rcu]   qstr-&gt;{name,len,hash}
  └─[d_lookup return]  NULL | dentry-&gt;d_name.name
     └─[miss path]
       ├─[__d_alloc entry]  qstr-&gt;name
       ├─[__d_alloc return] dentry-&gt;d_name.name
       └─[__d_add entry]    dentry-&gt;d_name.name
[do_filp_open return]  f-&gt;f_path.dentry-&gt;d_name.name
[d_delete entry]       dentry-&gt;d_name.name
[__dentry_kill entry]  dentry-&gt;d_name.name</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

User tests repo: https://github.com/raikrahul/what-happens-when-open-is-called/tree/main/kernel/user/stage2
Build and run:

1) Build the driver (repo root)</pre>
<pre><code>cd kernel/drivers/trace_do_filp_open &amp;&amp; make clean &amp;&amp; make</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

2) Run minimal_open (long filename)</pre>
<pre><code>cd kernel/user/stage2
sudo dmesg -C
sudo rmmod trace_do_filp_open
sudo insmod ../../drivers/trace_do_filp_open/trace_do_filp_open.ko target_comm=minimal_open
./minimal_open
sleep 5
sudo dmesg | rg -n "test_file_very_long_name_to_force_external_allocation"</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

WHAT TO RECORD (FILL THIS IN)
================================================================================

TEST 1: LONG FILENAME (minimal_open)

Why: isolate long-name allocation and later hit using a single name string.

PROGRAM 1: minimal_open.c</pre>
<pre><code class="language-c">#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char filename[128];
    time_t now = time(NULL);

    // Long filename; you will verify the allocation path with probes.
    snprintf(filename, sizeof(filename),
             "test_file_very_long_name_to_force_external_allocation_%ld", now);

    int fd = open(filename, O_RDWR | O_CREAT, 0644);
    printf("fd=%d
", fd);
    sleep(5);  // Delay lets us observe a later cache hit.
    close(fd);
    unlink(filename);
    return 0;
}</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Start at the equal-pointer checks, then link the same address across __d_alloc return → __d_add →
do_filp_open return → later d_lookup hit. Then walk backward and match each address to do_filp_open
entry (struct filename-&gt;name) and the dentry name on return. Every step must reuse a number already
written.

Record:
- do_filp_open entry pointer = 0x________ |
test_file_very_long_name_to_force_external_allocation_XXXX
- d_lookup entry: hash ________ length 64 name
test_file_very_long_name_to_force_external_allocation_XXXX
- d_lookup return: NULL
- __d_alloc entry pointer = 0x________
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | test_file_very_long_name_to_force_external_allocation_XXXX
- do_filp_open return pointer = 0x________ |
test_file_very_long_name_to_force_external_allocation_XXXX
- cache hit later: d_lookup return pointer = 0x________ |
test_file_very_long_name_to_force_external_allocation_XXXX
Diagram (pstree):</pre>
<pre><code>test_file_very_long_name_to_force_external_allocation_XXXX
└─ do_filp_open entry 0x________
   └─ d_lookup entry (hash=____, len=64, name=...)
      ├─ d_lookup return NULL
      │  └─ __d_alloc entry 0x________
      │     └─ __d_alloc return 0x________
      │        └─ __d_add entry 0x________ | test_file_...
      │           └─ do_filp_open return 0x________ | test_file_...
      └─ d_lookup return 0x________ | test_file_...</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">
Checks:
- __d_alloc return == __d_add entry == do_filp_open return
- cache hit pointer equals earlier return pointer

2b) Prepare loopback ext2 (a.txt)</pre>
<pre><code>sudo mkdir -p /mnt/loopfs
sudo dd if=/dev/zero of=/tmp/loopfs.img bs=1M count=64
sudo losetup -fP /tmp/loopfs.img
sudo mkfs.ext2 -F /tmp/loopfs.img
sudo mount /tmp/loopfs.img /mnt/loopfs
sudo sh -c 'echo x &gt; /mnt/loopfs/a.txt'
sync
sudo umount /mnt/loopfs
sudo mount /tmp/loopfs.img /mnt/loopfs</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

3) Run split programs (one at a time)</pre>
<pre><code>cd kernel/user/stage2
sudo dmesg -C
sudo rmmod trace_do_filp_open
sudo insmod ../../drivers/trace_do_filp_open/trace_do_filp_open.ko target_comm=&lt;program&gt;
sudo ./&lt;program&gt;
sleep 2
sudo dmesg | rg -n "t_e.txt|t_m.txt|l_m.txt|l_e.txt|a.txt|d_lookup entry|d_lookup return|__d_alloc|__d_add|do_filp_open|d_delete|__dentry_kill"</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: te_miss
- do_filp_open entry pointer = 0x________ | /tmp/t_e.txt
- d_lookup entry: hash ________ length 7 name t_e.txt
- d_lookup return: NULL
- __d_alloc entry pointer = 0x________
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | t_e.txt
- do_filp_open return pointer = 0x________ | t_e.txt
- offset check: (entry pointer + 5) == __d_alloc entry pointer
Diagram (pstree):</pre>
<pre><code>/tmp/t_e.txt
└─ do_filp_open entry 0x________
   └─ d_lookup entry (hash=____, len=7, name=t_e.txt)
      ├─ d_lookup return NULL
      │  └─ __d_alloc entry 0x________
      │     └─ __d_alloc return 0x________
      │        └─ __d_add entry 0x________ | t_e.txt
      │           └─ do_filp_open return 0x________ | t_e.txt
      └─ d_lookup return 0x________ | t_e.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: tm_miss
- do_filp_open entry pointer = 0x________ | /tmp/t_m.txt
- d_lookup entry: hash ________ length 7 name t_m.txt
- d_lookup return: NULL
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | t_m.txt
Diagram (pstree):</pre>
<pre><code>/tmp/t_m.txt
└─ do_filp_open entry 0x________
   └─ d_lookup entry (hash=____, len=7, name=t_m.txt)
      ├─ d_lookup return NULL
      │  └─ __d_alloc entry 0x________
      │     └─ __d_alloc return 0x________
      │        └─ __d_add entry 0x________ | t_m.txt
      └─ d_lookup return 0x________ | t_m.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: lm_miss
- do_filp_open entry pointer = 0x________ | l_m.txt
- d_lookup entry: hash ________ length 7 name l_m.txt
- d_lookup return: NULL
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | l_m.txt
Diagram (pstree):</pre>
<pre><code>l_m.txt
└─ do_filp_open entry 0x________
   └─ d_lookup entry (hash=____, len=7, name=l_m.txt)
      ├─ d_lookup return NULL
      │  └─ __d_alloc entry 0x________
      │     └─ __d_alloc return 0x________
      │        └─ __d_add entry 0x________ | l_m.txt
      └─ d_lookup return 0x________ | l_m.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: a_miss
- do_filp_open entry pointer = 0x________ | /mnt/loopfs/a.txt
- d_lookup entry: hash ________ length 5 name a.txt
- d_lookup return: NULL
- __d_alloc entry pointer = 0x________
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | a.txt
- do_filp_open return pointer = 0x________ | a.txt
- offset check: (entry pointer + 12) == __d_alloc entry pointer
Diagram (pstree):</pre>
<pre><code>/mnt/loopfs/a.txt
└─ do_filp_open entry 0x________
   └─ d_lookup entry (hash=____, len=5, name=a.txt)
      ├─ d_lookup return NULL
      │  └─ __d_alloc entry 0x________
      │     └─ __d_alloc return 0x________
      │        └─ __d_add entry 0x________ | a.txt
      │           └─ do_filp_open return 0x________ | a.txt
      └─ d_lookup return 0x________ | a.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: evict
- d_lookup return pointer = 0x________ | l_e.txt
- d_lookup return pointer = 0x________ | t_e.txt
- __dentry_kill entry = 0x________ | l_e.txt
- __dentry_kill entry = 0x________ | t_e.txt
Diagram (pstree):</pre>
<pre><code>l_e.txt
└─ d_lookup return 0x________ | l_e.txt
   └─ __dentry_kill entry 0x________ | l_e.txt
t_e.txt
└─ d_lookup return 0x________ | t_e.txt
   └─ __dentry_kill entry 0x________ | t_e.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: delete
- d_delete entry = 0x________ | l_e.txt
- d_delete entry = 0x________ | t_e.txt
Diagram (pstree):</pre>
<pre><code>l_e.txt
└─ d_delete entry 0x________ | l_e.txt
t_e.txt
└─ d_delete entry 0x________ | t_e.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: rebuild
- d_lookup return: NULL
- __d_alloc return pointer = 0x________
- __d_add entry pointer = 0x________ | t_e.txt
- do_filp_open return pointer = 0x________ | t_e.txt
- inequality check: rebuild pointer != pre-eviction pointer
Diagram (pstree):</pre>
<pre><code>/tmp/t_e.txt
└─ d_lookup return NULL
   └─ __d_alloc return 0x________
      └─ __d_add entry 0x________ | t_e.txt
         └─ do_filp_open return 0x________ | t_e.txt
0x________ ≠ 0x________</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Record: post
- __d_lookup_rcu entry: hash ________ length 7 name l_e.txt
- do_filp_open return pointer = 0x________ | l_e.txt
- inequality check: post-eviction pointer != pre-eviction pointer
Diagram (pstree):</pre>
<pre><code>l_e.txt
└─ __d_lookup_rcu entry (hash=____, len=7, name=l_e.txt)
   └─ do_filp_open return 0x________ | l_e.txt
0x________ ≠ 0x________</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Diagram (ASCII tree, fill with your numbers):</pre>
<pre><code>struct filename { name=0x________, str="..." }
└─ do_filp_open entry
   └─ qstr { name=0x________, len=__, hash=__, str="..." }
      └─ d_lookup entry
         ├─ d_lookup return NULL
         │  └─ __d_alloc entry
         │     └─ dentry { d_name.name=0x________, d_name.len=__, d_name.hash=__, d_name.str="..." }
         │        └─ __d_alloc return
         │           └─ __d_add entry
         │              └─ do_filp_open return pointer 0x________ | ...
         └─ d_lookup return 0x________ | ...</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">
} -&gt; __d_alloc return -&gt; __d_add entry -&gt; do_filp_open return pointer 0xffff8b14d0cc60f8 | t_e.txt
-&gt; d_lookup return pointer 0xffff8b149e488cf8 | t_e.txt on cache hit -&gt; d_delete entry
0xffff8b149e488cf8 | t_e.txt on unlink -&gt; __dentry_kill entry 0xffff8b149e488cf8 | t_e.txt on
drop_caches, and for the short-name case struct filename { name=0xffff8b148256b020,
str="/mnt/loopfs/a.txt" } -&gt; qstr { name=0xffff8b148256b02c, len=5, hash=2244109168, str="a.txt" }
-&gt; __d_alloc return dentry { d_name.name=0xffff8b14d0cc8e78, d_name.len=5, d_name.hash=2244109168,
d_name.str="a.txt" } -&gt; do_filp_open return pointer 0xffff8b14d0cc8e78 | a.txt, with the offsets
0xffff8b148256c025−0xffff8b148256c020=5 and 0xffff8b148256b02c−0xffff8b148256b020=12.



================================================================================

1. /usr/src/linux-source-6.8.0/fs/open.c + /usr/src/linux-source-6.8.0/fs/dcache.c → `nl -ba /usr/src/linux-source-6.8.0/fs/open.c | sed -n '1388,1436p'` → open/openat→do_filp_open ✓ → `nl -ba /usr/src/linux-source-6.8.0/fs/dcache.c | sed -n '2245,2265p'` → d_lookup(name,len,hash), NULL=miss ✓ → `rg -n "memcpy(dname, name-&gt;name, name-&gt;len)" /usr/src/linux-source-6.8.0/fs/dcache.c` → __d_alloc copy ✓ → `rg -n "__d_add\(|d_delete\(|__dentry_kill" /usr/src/linux-source-6.8.0/fs/dcache.c` → __d_add/d_delete/__dentry_kill ✓ → `nl -ba kernel/drivers/trace_do_filp_open/trace_do_filp_open.c | sed -n '82,90p'` → do_filp_open return pointer ✓
2. 0xffff8b148256c025−0xffff8b148256c020=0x5=5, /tmp/=5 ✓, compute?
3. 0xffff8b148256b02c−0xffff8b148256b020=0xC=12, /mnt/loopfs/=12 ✓, compute?
4. /tmp/t_e.txt: 0xffff8b148256c020→0xffff8b148256c025→0xffff8b14d0cc60f8→0xffff8b14d0cc60f8→0xffff8b14d0cc60f8 ✓, compute?
5. /tmp/t_m.txt: 0xffff8b1480ef5020→0xffff8b148d58d3f8→0xffff8b148d58d3f8 ✓, compute?
6. l_m.txt: 0xffff8b1482462020→0xffff8b14a70b6278→0xffff8b14a70b6278 ✓, compute?
7. /mnt/loopfs/a.txt: 0xffff8b148256b020→0xffff8b148256b02c→0xffff8b14d0cc8e78→0xffff8b14d0cc8e78 ✓, compute?
8. hit: 0xffff8b149e4886f8 + 0xffff8b149e488cf8 reused ✓, verify?
9. delete: d_delete 0xffff8b149e4886f8 + 0xffff8b149e488cf8 ✓, verify?
10. evict: __dentry_kill 0xffff8b149e4886f8 + 0xffff8b149e488cf8 ✓, verify?
11. rebuild: 0xffff8b14a712db78≠0xffff8b149e488cf8 ✗, verify?
12. post: 0xffff8b148a31f878≠0xffff8b149e4886f8 ✗, verify?
QUIZ (ANSWER YES/NO)
1. 0xffff8b14d0cc60f8=0xffff8b14d0cc60f8=0xffff8b14d0cc60f8 ✓? 2. 0xffff8b149e4886f8 unchanged
before delete ✓? 3. 0xffff8b148a31f878≠0xffff8b149e4886f8 ✓?</pre>
  </div>

</body>

</html>
