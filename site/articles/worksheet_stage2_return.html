<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return - Kernel Filename Tracing</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">================================================================================
USER SPACE TEST PROGRAMS
================================================================================

Location: https://github.com/raikrahul/what-happens-when-open-is-called/tree/main/kernel/user/stage2

PROGRAM 1: minimal_open.c (35 lines)
```c
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char filename[128];
    time_t now = time(NULL);
    
    // Forces external allocation (64 chars &gt; 32 byte inline buffer)
    snprintf(filename, sizeof(filename),
             "test_file_very_long_name_to_force_external_allocation_%ld", now);
    
    int fd = open(filename, O_RDWR | O_CREAT, 0644);
    printf("fd=%d\n", fd);
    sleep(5);  // Why? So we can open it again and see cache hit!
    close(fd);
    unlink(filename);
    return 0;
}
```

Key insight: 64-character filename forces kmalloc() instead of inline dentry buffer.

PROGRAM 2: matrix_open.c (38 lines)  
```c
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int main() {
    // Setup: create test files
    close(creat("l_e.txt", 0644));        // exists locally
    close(creat("/tmp/t_e.txt", 0644));   // exists in /tmp
    
    // Test scenarios:
    open("l_e.txt", O_RDONLY);           // 1: cached file
    open("/tmp/t_e.txt", O_RDONLY);      // 2: new file (first open)
    open("/tmp/t_m.txt", O_RDONLY);      // 3: missing file (ENOENT)
    open("l_e.txt", O_RDONLY);           // 4: second open (cache hit)
    open("l_m.txt", O_RDONLY);           // 5: missing file
    open("l_e.txt", O_RDONLY);           // 6: third open (cache hit)
    
    sleep(2);
    unlink("l_e.txt");
    unlink("/tmp/t_e.txt");
    return 0;
}
```

Tests: cache hit, allocation path, error handling, basename vs full path.

================================================================================
WHAT WE'RE TRACING
================================================================================

5 trace points capture filename addresses:

[O] IN  - do_filp_open ENTRY  : RSI=struct filename *   → capture -&gt;name
[A] SRC - __d_alloc ENTRY     : RSI=struct qstr *      → capture -&gt;name  
[A] DST - __d_alloc RETURN    : RAX=struct dentry *    → capture -&gt;d_name.name
[O] OUT - do_filp_open RETURN : RAX=struct file *      → capture -&gt;f_path.dentry-&gt;d_name.name
[L] HIT - d_lookup RETURN     : RAX=struct dentry *    → capture -&gt;d_name.name

The question: Does the filename survive from user space through the kernel?

The proof chain:
[O] IN → [A] SRC → [A] DST → [O] OUT  (allocation path)
[O] IN → [L] HIT → [O] OUT            (cache path)

Why two paths? d_lookup() checks cache before __d_alloc() creates new entry.
d_lookup returns NULL → allocation happens
d_lookup returns dentry → cache hit, skip allocation

================================================================================
CODE TO WRITE
================================================================================

File: kernel/drivers/trace_do_filp_open/trace_do_filp_open.c

Probe 1: Capture where filename was copied TO
```c
static int alloc_ret(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct dentry *d = (struct dentry *)regs-&gt;ax;  // RAX = return value
    if (d &amp;&amp; !IS_ERR(d)) {  // Kernel uses negative pointers as error codes
        pr_info("[A] DST: 0x%px\n", d-&gt;d_name.name);
    }
    return 0;
}
```

Probe 2: Capture filename in returned struct file
```c
static int open_ret(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct file *f = (struct file *)regs-&gt;ax;
    if (f &amp;&amp; !IS_ERR(f) &amp;&amp; f-&gt;f_path.dentry) {
        pr_info("[O] OUT: 0x%px | %s\n", 
                f-&gt;f_path.dentry-&gt;d_name.name,
                (char *)f-&gt;f_path.dentry-&gt;d_name.name);
    }
    return 0;
}
```

Probe 3: Capture cache hits
```c
static int lookup_ret(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct dentry *d = (struct dentry *)regs-&gt;ax;
    if (d &amp;&amp; !IS_ERR(d)) {
        pr_info("[L] HIT: 0x%px | %s\n",
                d-&gt;d_name.name,
                (char *)d-&gt;d_name.name);
    }
    return 0;
}
```

================================================================================
BUILD AND RUN
================================================================================

Build driver:
cd kernel/drivers/trace_do_filp_open &amp;&amp; make clean &amp;&amp; make
sudo insmod trace_do_filp_open.ko

Test 1 - Long filename (forces external allocation):
cd kernel/user/stage2
sudo dmesg -C
./minimal_open
sleep 5
sudo dmesg | grep -E "\[O\] IN|\[A\] SRC|\[A\] DST|\[O\] OUT|\[L\] HIT"

Record:
[O] IN  = 0x_____________________
[A] SRC = 0x_____________________
[A] DST = 0x_____________________
[O] OUT = 0x_____________________
[L] HIT = 0x_____________________ (appears after 5 sec delay)

Verify:
[O] IN == [A] SRC ? [ ] YES [ ] NO  (Copy source is original filename)
[A] DST == [O] OUT ? [ ] YES [ ] NO  (Returned file points to copy)
[L] HIT == [O] OUT ? [ ] YES [ ] NO  (Cache hit gives same address)

Test 2 - Matrix of scenarios:
sudo dmesg -C
./matrix_open
sleep 3
sudo dmesg | grep -E "\[O\] IN|\[A\] SRC|\[A\] DST|\[O\] OUT|\[L\] HIT"

FILE 1 (l_e.txt, exists → cache hit):
[O] IN  = 0x_____
[L] HIT = 0x_____
[O] OUT = 0x_____
[A] SRC captured? [ ] YES [ ] NO  ← NO means cache hit (no allocation)

FILE 2 (/tmp/t_e.txt, new → allocation):
[O] IN  = 0x_____
[A] SRC = 0x_____
[A] DST = 0x_____
[O] OUT = 0x_____
[L] HIT captured? [ ] YES [ ] NO  ← NO means not in cache
[O] IN - [A] SRC = _____ bytes  ← Why 5? strlen("/tmp/")

FILE 3 (/tmp/t_m.txt, missing → ENOENT):
[O] IN captured? [ ] YES [ ] NO
[O] OUT captured? [ ] YES [ ] NO  ← NO means error, no struct file returned

FILE 4 (l_m.txt, missing → ENOENT):
Same as FILE 3

FILE 5 (second opens → cache hits):
[L] HIT = 0x_____ (l_e.txt)
[L] HIT = 0x_____ (t_e.txt)
Match previous [O] OUT? [ ] YES [ ] NO  ← Cache preserves addresses

================================================================================
FIND THE COPY
================================================================================

Where does the actual copying happen?
grep -n "memcpy.*name-&gt;name" /usr/src/linux-headers-$(uname -r)/fs/dcache.c
Line: _____

Code:
memcpy(dname, name-&gt;name, name-&gt;len);

1st arg: destination buffer (dname = [A] DST)
2nd arg: source pointer (name-&gt;name = [A] SRC)
3rd arg: length in bytes (name-&gt;len)

Why copy? User buffer is temporary. Kernel needs permanent copy that survives
as long as the file is open. The dentry owns this copy.

================================================================================
WHY THIS MATTERS
================================================================================

The dentry cache (dcache) is why opening a file the second time is fast:

First open:
  User: open("/etc/passwd")
  Kernel: Walk path → d_lookup (miss) → __d_alloc → memcpy → cache entry
  Time: ~milliseconds

Second open:
  User: open("/etc/passwd")  
  Kernel: d_lookup (hit) → return cached dentry
  Time: ~microseconds

The filename lives in the dentry. The struct file just points to it.
This sharing is why the kernel can handle thousands of open files efficiently.

================================================================================
FAILURE MODES
================================================================================

1. Garbage address (0x6c69665f74736574 = "lif_tset")
   ∴ Reading string data as pointer
   → Use d-&gt;d_name.name not raw offset

2. Crash on error path
   ∴ Dereferencing error pointer (negative value)
   → Check IS_ERR(f) before deref

3. Kernel panic
   ∴ NULL pointer dereference
   → Check pointer valid

4. Wrong addresses captured
   ∴ Wrong register (RDI vs RSI for arg2)
   → x86_64: RDI=arg1, RSI=arg2, RDX=arg3

5. Module load fails
   ∴ Kernel version mismatch
   → make clean &amp;&amp; make

6. No output
   ∴ Process name filter mismatch
   → Check target_comm parameter

7. No [L] HIT
   ∴ d_lookup probe not registered
   → Ensure lookup_ret registered

8. Address mismatch
   ∴ Multiple path components, wrong dentry
   → Verify which dentry returned

9. Compile error
   ∴ Missing kernel headers
   → Install linux-headers-$(uname -r)

10. Random crashes
    ∴ Kprobe race condition
    → Expected, kprobes are for debugging only

================================================================================
UNDERSTANDING CHECKLIST
================================================================================

[ ] 3 probe functions written
[ ] Driver compiles and loads
[ ] minimal_open shows 5 addresses
[ ] All 3 proofs pass
[ ] matrix_open shows cache hit (no alloc for existing file)
[ ] matrix_open shows allocation (full chain for new file)
[ ] ENOENT returns no [O] OUT
[ ] Offset calculation explains /tmp/ prefix skip
[ ] memcpy located in kernel source
[ ] Understand why kernel copies (user buffer temporary)
[ ] Understand cache benefit (second open faster)
[ ] All 10 failures reviewed

All checked ∴ Filename survival proven.</pre>
  </div>

</body>

</html>