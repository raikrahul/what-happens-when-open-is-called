<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return - Kernel Filename Tracing (Copy vs Cache)</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">================================================================================
USER SPACE TEST PROGRAMS (AND WHY THEY EXIST)
================================================================================

Location: https://github.com/raikrahul/what-happens-when-open-is-called/tree/main/kernel/user/stage2

PROGRAM 1: minimal_open.c
```c
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char filename[128];
    time_t now = time(NULL);
    
    // Forces external allocation (name &gt; inline dentry buffer)
    snprintf(filename, sizeof(filename),
             "test_file_very_long_name_to_force_external_allocation_%ld", now);
    
    int fd = open(filename, O_RDWR | O_CREAT, 0644);
    printf("fd=%d\n", fd);
    sleep(5);  // Delay lets us observe a later cache hit.
    close(fd);
    unlink(filename);
    return 0;
}
```

Key insight: A long name forces external allocation in the dentry name path.

PROGRAM 2: matrix_open.c
```c
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;

int main() {
    // Setup: create test files
    close(creat("l_e.txt", 0644));        // exists locally
    close(creat("/tmp/t_e.txt", 0644));   // exists in /tmp
    
    // Test scenarios:
    open("l_e.txt", O_RDONLY);           // 1: cached file
    open("/tmp/t_e.txt", O_RDONLY);      // 2: new file (first open)
    open("/tmp/t_m.txt", O_RDONLY);      // 3: missing file (ENOENT)
    open("l_e.txt", O_RDONLY);           // 4: second open (cache hit)
    open("l_m.txt", O_RDONLY);           // 5: missing file
    open("l_e.txt", O_RDONLY);           // 6: third open (cache hit)
    
    sleep(2);
    unlink("l_e.txt");
    unlink("/tmp/t_e.txt");
    return 0;
}
```

Tests: cache hit, allocation path, ENOENT, basename vs full path.

================================================================================
WHAT WE'RE TRACING (POINTERS, NOT FEELINGS)
================================================================================

Goal: find where the name is copied and when it is reused.

Minimal facts (self contained):
- getname copies the user string into kernel memory
- do_filp_open uses struct filename and its name pointer
- __d_alloc copies qstr-&gt;name into dentry-&gt;d_name.name
- d_lookup returns an existing dentry on cache hit
- do_filp_open returns a struct file that points at the dentry name

5 trace points capture name pointers:

[O] IN  - do_filp_open entry  : struct filename * -&gt; capture name
[A] SRC - __d_alloc entry     : struct qstr *     -&gt; capture name
[A] DST - __d_alloc return    : struct dentry *   -&gt; capture d_name.name
[O] OUT - do_filp_open return : struct file *     -&gt; capture f_path.dentry-&gt;d_name.name
[L] HIT - d_lookup return     : struct dentry *   -&gt; capture d_name.name

Two chains:
[O] IN -&gt; [A] SRC -&gt; [A] DST -&gt; [O] OUT  (allocation path)
[O] IN -&gt; [L] HIT -&gt; [O] OUT            (cache path)

Why two paths: d_lookup checks cache before __d_alloc creates a new dentry.
d_lookup returns NULL  -&gt; allocation happens
d_lookup returns dentry -&gt; cache hit, skip allocation

================================================================================
DRIVER NOTE (DO THIS OR YOU WILL SEE NOTHING)
================================================================================

The driver filters by process name:
- Default target is `matrix_open`.
- For `minimal_open`, you must load with: `target_comm=minimal_open`

If you forget this, your logs will be empty for that program and you will
diagnose a phantom bug.

================================================================================
CODE TO WRITE
================================================================================

File: kernel/drivers/trace_do_filp_open/trace_do_filp_open.c

Probe 1: Capture where filename was copied TO
```c
static int alloc_ret(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct dentry *d = (struct dentry *)regs-&gt;ax;  // RAX = return value
    if (d &amp;&amp; !IS_ERR(d)) {  // Kernel uses negative pointers as error codes
        pr_info("[A] DST: 0x%px\n", d-&gt;d_name.name);
    }
    return 0;
}
```

Probe 2: Capture filename in returned struct file
```c
static int open_ret(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct file *f = (struct file *)regs-&gt;ax;
    if (f &amp;&amp; !IS_ERR(f) &amp;&amp; f-&gt;f_path.dentry) {
        pr_info("[O] OUT: 0x%px | %s\n", 
                f-&gt;f_path.dentry-&gt;d_name.name,
                (char *)f-&gt;f_path.dentry-&gt;d_name.name);
    }
    return 0;
}
```

Probe 3: Capture cache hits
```c
static int lookup_ret(struct kretprobe_instance *ri, struct pt_regs *regs) {
    struct dentry *d = (struct dentry *)regs-&gt;ax;
    if (d &amp;&amp; !IS_ERR(d)) {
        pr_info("[L] HIT: 0x%px | %s\n",
                d-&gt;d_name.name,
                (char *)d-&gt;d_name.name);
    }
    return 0;
}
```

================================================================================
BUILD AND RUN
================================================================================

Build driver:
cd kernel/drivers/trace_do_filp_open &amp;&amp; make clean &amp;&amp; make

Load driver (choose target):
sudo insmod trace_do_filp_open.ko target_comm=minimal_open
sudo rmmod trace_do_filp_open
sudo insmod trace_do_filp_open.ko target_comm=matrix_open

Test 1 - Long filename (forces external allocation):
cd kernel/user/stage2
sudo dmesg -C
./minimal_open
sleep 5
sudo dmesg | grep -E "\[O\] IN|\[A\] SRC|\[A\] DST|\[O\] OUT|\[L\] HIT"

Input -&gt; Computation -&gt; Output:
User long name -&gt; __d_alloc copies name -&gt; [A] DST == [O] OUT, later [L] HIT

Record (ignore libc/ld.so loader noise):
[O] IN  = 0x_____________________
[A] SRC = 0x_____________________
[A] DST = 0x_____________________
[O] OUT = 0x_____________________
[L] HIT = 0x_____________________ (appears after 5 sec delay)

Check (allocation path):
[O] IN == [A] SRC ? [ ] YES [ ] NO  (Copy source is original filename)
[A] DST == [O] OUT ? [ ] YES [ ] NO  (Returned file points to copy)
[L] HIT == [O] OUT ? [ ] YES [ ] NO  (Cache hit gives same address)

Test 2 - Matrix of scenarios:
sudo dmesg -C
./matrix_open
sleep 3
sudo dmesg | grep -E "\[O\] IN|\[A\] SRC|\[A\] DST|\[O\] OUT|\[L\] HIT"

Input -&gt; Computation -&gt; Output:
Existing file -&gt; d_lookup hit -&gt; [L] HIT == [O] OUT
New file -&gt; __d_alloc -&gt; [A] DST == [O] OUT
Missing file -&gt; no struct file -&gt; no [O] OUT

FILE 1 (l_e.txt, exists - cache hit):
[O] IN  = 0x_____
[L] HIT = 0x_____
[O] OUT = 0x_____
[A] SRC captured? [ ] YES [ ] NO  - NO means cache hit (no allocation)

FILE 2 (/tmp/t_e.txt, new - allocation):
[O] IN  = 0x_____
[A] SRC = 0x_____
[A] DST = 0x_____
[O] OUT = 0x_____
[L] HIT captured? [ ] YES [ ] NO  - NO means not in cache
[O] IN - [A] SRC = _____ bytes  - Why 5? strlen("/tmp/")

FILE 3 (/tmp/t_m.txt, missing - ENOENT):
[O] IN captured? [ ] YES [ ] NO
[O] OUT captured? [ ] YES [ ] NO  - NO means error, no struct file returned

FILE 4 (l_m.txt, missing - ENOENT):
Same as FILE 3

FILE 5 (second opens - cache hits):
[L] HIT = 0x_____ (l_e.txt)
[L] HIT = 0x_____ (t_e.txt)
Match previous [O] OUT? [ ] YES [ ] NO  - Cache preserves addresses

================================================================================
FIND THE COPY
================================================================================

Where does the actual copying happen?
grep -n "memcpy.*name-&gt;name" /usr/src/linux-headers-$(uname -r)/fs/dcache.c
Line: _____

Code:
memcpy(dname, name-&gt;name, name-&gt;len);

1st arg: destination buffer (dname = [A] DST)
2nd arg: source pointer (name-&gt;name = [A] SRC)
3rd arg: length in bytes (name-&gt;len)

Why copy? User buffer is temporary. Kernel needs permanent copy that survives
as long as the file is open. The dentry owns this copy.

================================================================================
WHY THIS MATTERS
================================================================================

The dentry cache (dcache) is why opening a file the second time is fast:

First open:
  User: open("/etc/passwd")
  Kernel: Walk path then d_lookup (miss) then __d_alloc then memcpy then cache entry
  Time: ~milliseconds

Second open:
  User: open("/etc/passwd")  
  Kernel: d_lookup (hit) then return cached dentry
  Time: ~microseconds

The filename lives in the dentry. The struct file just points to it.
This sharing is why the kernel can handle thousands of open files efficiently.

================================================================================
FAILURE MODES
================================================================================

1. Garbage address (0x6c69665f74736574 = "lif_tset")
   Reading string data as a pointer.
   Use d-&gt;d_name.name, not a raw field.

2. Crash on error path
   Dereferencing an error pointer (negative value).
   Check IS_ERR(f) before deref.

3. Kernel panic
   NULL pointer dereference.
   Check pointer before deref.

4. Wrong addresses captured
   Wrong function argument captured.
   Use the second argument for filename or qstr.

5. Module load fails
   Kernel version mismatch.
   make clean &amp;&amp; make

6. No output
   Process name filter mismatch.
   Check target_comm parameter.

7. No [L] HIT
   d_lookup probe not registered.
   Ensure lookup_ret registered.

8. Address mismatch
   Multiple path components, wrong dentry.
   Check which dentry returned.

9. Compile error
   Missing kernel headers.
   Install linux-headers-$(uname -r)

10. Random crashes
    Kprobe race condition.
    Expected, kprobes are for debugging only.

================================================================================
UNDERSTANDING CHECKLIST
================================================================================

[ ] 3 probe functions written
[ ] Driver compiles and loads
[ ] minimal_open shows 5 addresses
[ ] All 3 proofs pass
[ ] matrix_open shows cache hit (no alloc for existing file)
[ ] matrix_open shows allocation (full chain for new file)
[ ] ENOENT returns no [O] OUT
[ ] Offset calculation explains /tmp/ prefix skip
[ ] memcpy located in kernel source
[ ] Understand why kernel copies (user buffer temporary)
[ ] Understand cache benefit (second open faster)
[ ] All 10 failures reviewed

All checked. Filename survival shown.</pre>
  </div>

</body>

</html>