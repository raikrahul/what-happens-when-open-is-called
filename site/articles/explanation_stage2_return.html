<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>window.addEventListener('DOMContentLoaded', () => { if (window.hljs) hljs.highlightAll(); });</script>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    pre code {
      display: block;
      white-space: pre;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">QUESTION

Where does the filename string live when do_filp_open returns?

ANSWER

The filename lives in dentry-&gt;d_name.name. The returned struct file points to this address.

PROOF METHOD

Print kernel pointers at 5 locations. Compare addresses. If address A equals address B, they point to the same memory.

KERNEL FUNCTIONS TRACED

do_filp_open - opens file, returns struct file *
__d_alloc - allocates dentry, copies name
d_lookup - searches dentry cache
__d_add - inserts dentry into cache
__dentry_kill - frees dentry on eviction

PROBE LOCATIONS

[O] IN  - do_filp_open entry  : struct filename-&gt;name (RSI register, offset +0)
[A] SRC - __d_alloc entry     : struct qstr-&gt;name (RSI register, offset +8)
[A] DST - __d_alloc return    : struct dentry-&gt;d_name.name (RAX register, offset +40)
[O] OUT - do_filp_open return : struct file-&gt;f_path.dentry-&gt;d_name.name (RAX register)
[L] HIT - d_lookup return     : struct dentry-&gt;d_name.name (RAX register, offset +40)

REGISTER CONVENTIONS (x86_64)

RSI = second function argument
RAX = return value
regs-&gt;si = read RSI
regs-&gt;ax = read RAX

STRUCT OFFSETS (kernel 6.8)

struct filename {
    const char *name;         // offset +0
    const __user char *uptr;  // offset +8
    int refcnt;               // offset +16
    struct qstr name_attr;    // offset +24
};

struct qstr {
    u32 hash;                 // offset +0
    u32 len;                  // offset +4
    const unsigned char *name;// offset +8
};

struct dentry {
    unsigned int d_flags;     // offset +0
    seqcount_spinlock_t d_seq;// offset +4
    struct hlist_bl_node d_hash;// offset +8
    struct dentry *d_parent;  // offset +24
    struct qstr d_name;       // offset +32
    struct inode *d_inode;    // offset +48
    char d_shortname[32];     // offset +56
};

struct file {
    file_ref_t f_ref;         // offset +0
    spinlock_t f_lock;        // offset +8
    fmode_t f_mode;           // offset +12
    unsigned int f_flags;     // offset +48
    struct path f_path;       // offset +72
};

struct path {
    struct vfsmount *mnt;     // offset +0
    struct dentry *dentry;    // offset +8
};

OFFSET CALCULATION

dentry-&gt;d_name.name = dentry + 32 + 8 = dentry + 40

TWO PATHS

Path 1 (allocation): [O] IN -&gt; [A] SRC -&gt; [A] DST -&gt; [O] OUT
Path 2 (cache hit):  [O] IN -&gt; [L] HIT -&gt; [O] OUT

d_lookup checks cache first.
d_lookup returns NULL -&gt; __d_alloc runs -&gt; memcpy happens -&gt; __d_add inserts
d_lookup returns dentry -&gt; cache hit -&gt; no allocation

MEMCPY LOCATION

File: /usr/src/linux-source-6.8.0/fs/dcache.c
Function: __d_alloc
Line: 1651
Code: memcpy(dname, name-&gt;name, name-&gt;len);

Arguments:
dname = destination buffer (new dentry name)
name-&gt;name = source pointer (from struct qstr)
name-&gt;len = bytes to copy

PROOF 1: ALLOCATION PATH (minimal_open.c)

Test program creates file with 64-character name.

Code:
snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);

Trace output:
[O] IN  = 0xffff8976c6763020 | test_file_very_long_name_to_force_external_allocation_1770466275
[A] SRC = 0xffff8976c6763020
[A] DST = 0xffff8977eb463eb8
[O] OUT = 0xffff8977eb463eb8 | test_file_very_long_name_to_force_external_allocation_1770466275

Verification:
[O] IN == [A] SRC: 0xffff8976c6763020 == 0xffff8976c6763020 ✓
[A] DST == [O] OUT: 0xffff8977eb463eb8 == 0xffff8977eb463eb8 ✓

Conclusion: __d_alloc copies from [O] IN to [A] DST. do_filp_open returns pointer to [A] DST.

PROOF 2: CACHE HIT PATH (minimal_open.c continued)

Test program sleeps 5 seconds, file remains open.

Trace output (5 seconds later):
[L] HIT = 0xffff8977eb463eb8 | test_file_very_long_name_to_force_external_allocation_1770466275

Verification:
[L] HIT == [O] OUT: 0xffff8977eb463eb8 == 0xffff8977eb463eb8 ✓

Conclusion: Second open hits cache. Returns same address as first open.

PROOF 3: BASENAME OFFSET (te_miss.c)

Test program opens /tmp/t_e.txt after cache drop.

Code:
const char *n2 = "/tmp/t_e.txt";
close(creat(n2, 0644));
drop_caches_if_root();
sleep(1);
open(n2, O_RDONLY);

Trace output:
[O] IN  = 0xffff8976cc495020 | /tmp/t_e.txt
[A] SRC = 0xffff8976cc495025
[A] DST = 0xffff8976e1999b78
[O] OUT = 0xffff8976e1999b78 | t_e.txt

Calculation:
0xffff8976cc495025 - 0xffff8976cc495020 = 0x5 = 5 bytes

Verification:
strlen("/tmp/") = 5 ✓

Conclusion: __d_alloc receives pointer to basename, not full path. Offset equals prefix length.

PROOF 4: NEGATIVE DENTRY (tm_miss.c)

Test program opens missing file twice.

Code:
const char *n3 = "/tmp/t_m.txt";
drop_caches_if_root();
sleep(1);
int fd1 = open(n3, O_RDONLY);  // returns -1
int fd2 = open(n3, O_RDONLY);  // returns -1

Trace output (first open):
[O] IN  = 0xffff8976c905b020 | /tmp/t_m.txt
[A] SRC = 0xffff8976c905b025
[A] DST = 0xffff897725f170f8
(no [O] OUT because open failed)

Trace output (second open):
[L] HIT = 0xffff897725f170f8 | t_m.txt

Verification:
First open creates dentry at 0xffff897725f170f8
Second open hits cache at 0xffff897725f170f8 ✓
Both opens return fd=-1 ✓

Conclusion: Missing file creates cached dentry with d_inode=NULL. Second open hits cache, avoids disk lookup.

Kernel source proof:
File: /usr/src/linux-source-6.8.0/include/linux/dcache.h
struct dentry { struct inode *d_inode; /* NULL is negative */ };
static inline bool d_really_is_negative(const struct dentry *dentry) {
    return dentry-&gt;d_inode == NULL;
}

PROOF 5: EVICTION (rebuild.c)

Test program opens file, drops cache, opens again.

Code:
open("/tmp/t_e.txt", O_RDONLY);
drop_caches_if_root();
open("/tmp/t_e.txt", O_RDONLY);

Trace output (before drop_caches):
[A] DST = 0xffff8977185a9578
[O] OUT = 0xffff8977185a9578 | t_e.txt

Trace output (after drop_caches):
[A] DST = 0xffff8977f40ec278
[O] OUT = 0xffff8977f40ec278 | t_e.txt

Calculation:
0xffff8977f40ec278 - 0xffff8977185a9578 = 0xdbb42d00 = 3686018304 bytes

Verification:
0xffff8977f40ec278 ≠ 0xffff8977185a9578 ✓

Conclusion: drop_caches evicts dentry. Next open allocates new dentry at different address.

ERROR CASE

Test program opens missing file without O_CREAT.

Code:
open("l_m.txt", O_RDONLY);  // file does not exist

Trace output:
[O] IN  = 0xffff8976c643c020 | l_m.txt
[A] SRC = 0xffff8976c643c020
[A] DST = 0xffff89775bf497b8
(no [O] OUT)

Conclusion: Path walk fails. No struct file created. No [O] OUT printed.

DRIVER FILTER

Driver filters by process name. Default target is "matrix_open".

Load driver for minimal_open:
sudo insmod trace_do_filp_open.ko target_comm=minimal_open

Load driver for matrix_open:
sudo insmod trace_do_filp_open.ko target_comm=matrix_open

If target_comm does not match, no output appears.

BUILD AND RUN

Build driver:
cd kernel/drivers/trace_do_filp_open &amp;&amp; make clean &amp;&amp; make

Load driver:
sudo insmod trace_do_filp_open.ko target_comm=minimal_open

Run test:
cd kernel/user/stage2
./minimal_open

Read kernel log:
sudo dmesg | grep -E "\[O\] IN|\[A\] SRC|\[A\] DST|\[O\] OUT|\[L\] HIT"

Unload driver:
sudo rmmod trace_do_filp_open

OFFSET BUG WARNING

Wrong offset causes garbage reads.

Example: Using offset +48 instead of +32 for d_name reads string data as pointer.

Debug output with wrong offset:
dname_ptr = 0x6c69665f74736574

Hex decode:
0x6c = 'l'
0x69 = 'i'
0x66 = 'f'
0x5f = '_'
0x74 = 't'
0x73 = 's'
0x65 = 'e'
0x74 = 't'

Result: "lif_tset" (filename backwards)

Fix: Verify offsets with pahole or kernel headers.

Command:
pahole -C dentry /lib/modules/$(uname -r)/build/vmlinux

Output shows d_name at offset +32, not +48.

KERNEL SOURCE LOCATIONS

do_filp_open: /usr/src/linux-source-6.8.0/fs/open.c
__d_alloc: /usr/src/linux-source-6.8.0/fs/dcache.c line 1651
d_lookup: /usr/src/linux-source-6.8.0/fs/dcache.c
__d_add: /usr/src/linux-source-6.8.0/fs/dcache.c
d_delete: /usr/src/linux-source-6.8.0/fs/dcache.c
__dentry_kill: /usr/src/linux-source-6.8.0/fs/dcache.c

struct filename: /usr/src/linux-source-6.8.0/include/linux/fs.h
struct file: /usr/src/linux-source-6.8.0/include/linux/fs.h
struct dentry: /usr/src/linux-source-6.8.0/include/linux/dcache.h
struct qstr: /usr/src/linux-source-6.8.0/include/linux/dcache.h
struct path: /usr/src/linux-source-6.8.0/include/linux/path.h

CONCLUSION

Filename lives in dentry-&gt;d_name.name.

Allocation path: __d_alloc copies name from struct qstr to dentry.
Cache hit path: d_lookup returns existing dentry.
Both paths: do_filp_open returns struct file pointing to dentry name.

Proof: Same numeric address appears at [A] DST and [O] OUT (allocation path).
Proof: Same numeric address appears at [L] HIT and [O] OUT (cache hit path).
Proof: Address changes after drop_caches (eviction path).
Proof: Missing file creates negative dentry (d_inode=NULL).

All claims verified with printed kernel pointers.</pre>
  </div>

</body>

</html>
