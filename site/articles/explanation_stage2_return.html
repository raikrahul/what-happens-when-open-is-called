<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>window.addEventListener('DOMContentLoaded', () => { if (window.hljs) hljs.highlightAll(); });</script>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    pre code {
      display: block;
      white-space: pre;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">Prior Work

Stage 1: https://raikrahul.github.io/what-happens-when-open-is-called/stage1.html
Stage 2 Entry: https://raikrahul.github.io/what-happens-when-open-is-called/stage2.html
Worksheet: https://raikrahul.github.io/what-happens-when-open-is-called/articles/worksheet_stage2_return.html

Programs

minimal_open.c</pre>
<pre><code class="language-c">snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);
sleep(5);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

matrix_open.c</pre>
<pre><code class="language-c">close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
sleep(2);
close_all();
unlink("l_e.txt");
unlink("/tmp/t_e.txt");
close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Per-line purpose is in the inline `//` comments in `kernel/user/stage2/matrix_open.c`. Each open,
unlink, and drop_caches call is annotated next to the code line, so no duplicate listing appears
here.

Loopback filesystem test:

- 64M loopback file formatted as ext2
- mounted at /mnt/loopfs
- a.txt created, sync, unmount, remount

Probe map</pre>
<pre><code class="language-text">do_filp_open entry -&gt; input filename pointer + string -&gt; establishes kernel-side name before lookup -&gt; driver open entry probe
__d_alloc entry -&gt; copy source pointer -&gt; shows which basename string is copied -&gt; driver alloc entry probe
__d_alloc return -&gt; copy destination pointer -&gt; identifies new dentry name storage -&gt; driver alloc return probe
do_filp_open return -&gt; returned file name pointer -&gt; ties file to dentry name storage -&gt; driver open return probe
d_lookup entry -&gt; hash, length, name -&gt; defines lookup key used for cache search -&gt; driver lookup entry probe
d_lookup return -&gt; dentry name pointer or NULL -&gt; proves hit or miss -&gt; driver lookup return probe
__d_lookup entry -&gt; hash, length, name -&gt; internal lookup path key -&gt; driver __d_lookup probe
__d_lookup_rcu entry -&gt; hash, length, name -&gt; RCU fast-path lookup key -&gt; driver __d_lookup_rcu probe
full_name_hash return -&gt; hash, length, salt, name -&gt; records hash computation (if observed) -&gt; driver hash ret probe
__d_add entry -&gt; dentry name pointer -&gt; proves cache insert -&gt; driver __d_add probe
d_delete entry -&gt; dentry name pointer -&gt; proves unlink removal -&gt; driver d_delete probe
__dentry_kill entry -&gt; dentry name pointer -&gt; proves eviction via drop_caches -&gt; driver __dentry_kill probe</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

File: /usr/src/linux-source-6.8.0/fs/dcache.c:1660 memcpy(dname, name-&gt;name, name-&gt;len);

<table>
  <tr>
    <td>
      <pre><code>1) memcpy chain (t_e.txt, copy source -> destination)
"/tmp/t_e.txt" @ 0xffff8bd54c33e020 -> __d_alloc entry 0xffff8bd54c33e025 -> __d_alloc return 0xffff8bd54eaa09f8
2) cache build-up chain (t_e.txt, miss -> insert)
d_lookup return NULL -> __d_add 0xffff8bd54eaa09f8 -> do_filp_open return 0xffff8bd54eaa09f8
3) cache hit chain (t_e.txt, later lookup)
d_lookup return 0xffff8bd54eaa09f8 -> do_filp_open return 0xffff8bd54eaa09f8
4) cache miss chain (t_m.txt, missing)
"/tmp/t_m.txt" -> d_lookup return NULL -> __d_add 0xffff8bd54eaa0e78
5) cache delete chain (unlink)
d_delete 0xffff8bd5628ba9f8 (l_e.txt) + d_delete 0xffff8bd54eaa09f8 (t_e.txt)
Later phases start after this: eviction (__dentry_kill) and rebuild after eviction.</code></pre>
    </td>
    <td>
      <pre><code>t_e.txt miss → alloc → insert → return
open("/tmp/t_e.txt")
  -> do_filp_open entry 0xffff8bd54c33e020
  -> d_lookup hash 1830572521 len 7 "t_e.txt" -> NULL
  -> __d_alloc entry 0xffff8bd54c33e025
  -> __d_alloc return 0xffff8bd54eaa09f8
  -> __d_add entry 0xffff8bd54eaa09f8
  -> do_filp_open return 0xffff8bd54eaa09f8

a.txt miss on loopback ext2
open("/mnt/loopfs/a.txt")
  -> do_filp_open entry 0xffff8bd54c33e020
  -> d_lookup hash 3711754354 len 5 "a.txt" -> NULL
  -> __d_alloc entry 0xffff8bd54c33e02c
  -> __d_alloc return 0xffff8bd54eaa04b8
  -> __d_add entry 0xffff8bd54eaa04b8
  -> do_filp_open return 0xffff8bd54eaa04b8

cache hit for l_e.txt before deletion
open("l_e.txt")
  -> d_lookup hash 440978933 len 7 "l_e.txt" -> 0xffff8bd5628ba9f8
  -> do_filp_open return 0xffff8bd5628ba9f8

unlink deletion + eviction
unlink("l_e.txt") -> d_delete 0xffff8bd5628ba9f8
unlink("/tmp/t_e.txt") -> d_delete 0xffff8bd54eaa09f8
drop_caches -> __dentry_kill 0xffff8bd5628ba9f8 (l_e.txt)
drop_caches -> __dentry_kill 0xffff8bd54eaa09f8 (t_e.txt)
drop_caches -> __dentry_kill 0xffff8bd54eaa0e78 (t_m.txt)
drop_caches -> __dentry_kill 0xffff8bd54eaa0278 (l_m.txt)
drop_caches -> __dentry_kill 0xffff8bd54eaa04b8 (a.txt)

rebuild after eviction (t_e.txt)
open("/tmp/t_e.txt") after drop_caches
  -> d_lookup hash 1830572521 len 7 "t_e.txt" -> NULL
  -> __d_alloc return 0xffff8bd54eaa0338
  -> __d_add entry 0xffff8bd54eaa0338
  -> do_filp_open return 0xffff8bd54eaa0338

post-eviction lookup for l_e.txt
open("l_e.txt") after drop_caches
  -> __d_lookup_rcu hash 440978933 len 7 "l_e.txt"
  -> do_filp_open return 0xffff8bd5450e8278</code></pre>
    </td>
  </tr>
</table>

Run A: matrix_open (root, drop_caches enabled)

t_e.txt miss, memcpy, insert.</pre>
<pre><code class="language-c">char n2[] = "/tmp/t_e.txt";
close(creat(n2, 0644));
drop_caches_if_root();
sleep(1);

f[1] = open(n2, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: do_filp_open entry pointer = 0xffff8bd54c33e020 | /tmp/t_e.txt d_lookup entry: hash
1830572521 length 7 name t_e.txt d_lookup return: NULL __d_alloc entry pointer = 0xffff8bd54c33e025
__d_alloc return pointer = 0xffff8bd54eaa09f8 __d_add entry: 0xffff8bd54eaa09f8 | t_e.txt
do_filp_open return pointer = 0xffff8bd54eaa09f8 | t_e.txt

Pointer meanings and path reasoning (t_e.txt).
The kernel copy of the path appears first: do_filp_open entry pointer = 0xffff8bd54c33e020 | /tmp/t_e.txt. That address is used at entry, so it is the kernel-resident string for this call and not the dentry name pointer. The printed string fixes the exact name for this call.
Lookup uses the basename: d_lookup entry prints hash 1830572521 length 7 name t_e.txt, so the key is the basename and its length. If the full path were used, the length would be 12, not 7.
The miss is explicit: d_lookup return: NULL. With no cached dentry for that key, lookup returns NULL and allocation follows.
Allocation uses a shifted pointer: __d_alloc entry pointer = 0xffff8bd54c33e025. The difference from 0xffff8bd54c33e020 is 5 bytes, which matches "/tmp/". That proves the copy source is the basename start inside the same kernel string.
New storage appears: __d_alloc return pointer = 0xffff8bd54eaa09f8. This is distinct from the string pointer, so it is newly allocated name storage.
Insertion is explicit: __d_add entry: 0xffff8bd54eaa09f8 | t_e.txt. The inserted pointer matches the allocation return, so the dcache now contains that name at that address.
Return ties the file to the inserted name: do_filp_open return pointer = 0xffff8bd54eaa09f8 | t_e.txt. The return pointer equals the allocation and insertion pointer, so the file points to that copied name storage.

Compact map (t_e.txt).
"/tmp/t_e.txt" @ 0xffff8bd54c33e020 -&gt; d_lookup (t_e.txt, 7, 1830572521) -&gt; NULL -&gt; __d_alloc entry 0xffff8bd54c33e025 -&gt; __d_alloc return 0xffff8bd54eaa09f8 -&gt; __d_add 0xffff8bd54eaa09f8 -&gt; do_filp_open return 0xffff8bd54eaa09f8.

Derivation.
Derivation (data): 0xffff8bd54c33e025 - 0xffff8bd54c33e020 = 0x5 = 5 "/tmp/" length = 5
0xffff8bd54eaa09f8 = __d_alloc return pointer 0xffff8bd54eaa09f8 = __d_add entry pointer
0xffff8bd54eaa09f8 = do_filp_open return pointer

t_m.txt miss, insert.</pre>
<pre><code class="language-c">char n3[] = "/tmp/t_m.txt";

f[2] = open(n3, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: do_filp_open entry pointer = 0xffff8bd54c33e020 | /tmp/t_m.txt d_lookup entry: hash
2543581516 length 7 name t_m.txt d_lookup return: NULL __d_alloc entry pointer = 0xffff8bd54c33e025
__d_alloc return pointer = 0xffff8bd54eaa0e78 __d_add entry: 0xffff8bd54eaa0e78 | t_m.txt

The entry pointer is 0xffff8bd54c33e020 and the string is /tmp/t_m.txt, so the kernel copy for this call is fixed to that address. The lookup key is the basename, shown as t_m.txt with length 7 and hash 2543581516, so the lookup uses 7 bytes and not 12. The lookup returns NULL, so the cache has no entry for that key at this time. The allocation source pointer is 0xffff8bd54c33e025, which is 0xffff8bd54c33e020 + 5; that 5 matches the length of “/tmp/”, so the copy source begins at the basename inside the same string. The allocation return pointer is 0xffff8bd54eaa0e78, which is distinct from the string pointer and therefore new storage. The insert line uses 0xffff8bd54eaa0e78, so the same new storage is placed into the dcache. The numeric link is 0xffff8bd54c33e025 − 0xffff8bd54c33e020 = 0x5 = 5.

Compact map (t_m.txt).
"/tmp/t_m.txt" @ 0xffff8bd54c33e020 -&gt; d_lookup (t_m.txt, 7, 2543581516) -&gt; NULL -&gt; __d_alloc entry 0xffff8bd54c33e025 -&gt; __d_alloc return 0xffff8bd54eaa0e78 -&gt; __d_add 0xffff8bd54eaa0e78.

l_m.txt miss, insert.</pre>
<pre><code class="language-c">char n4[] = "l_m.txt";

f[4] = open(n4, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: do_filp_open entry pointer = 0xffff8bd54c33e020 | l_m.txt d_lookup entry: hash
2166850383 length 7 name l_m.txt d_lookup return: NULL __d_alloc entry pointer = 0xffff8bd54c33e020
__d_alloc return pointer = 0xffff8bd54eaa0278 __d_add entry: 0xffff8bd54eaa0278 | l_m.txt

The entry pointer is 0xffff8bd54c33e020 and the string is l_m.txt, so the kernel copy and the basename start are the same address. The lookup key is l_m.txt with length 7 and hash 2166850383, so the lookup uses 7 bytes. The lookup returns NULL, so there is no cached entry for that key. The allocation source pointer is again 0xffff8bd54c33e020, confirming no prefix shift. The allocation return pointer is 0xffff8bd54eaa0278, which is new storage. The insert line uses 0xffff8bd54eaa0278, so that same storage becomes the cached name entry.

a.txt miss, memcpy, insert (loopback ext2).</pre>
<pre><code class="language-c">char n5[] = "/mnt/loopfs/a.txt";

f[5] = open(n5, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: do_filp_open entry pointer = 0xffff8bd54c33e020 | /mnt/loopfs/a.txt d_lookup entry:
hash 3711754354 length 5 name a.txt d_lookup return: NULL __d_alloc entry pointer =
0xffff8bd54c33e02c __d_alloc return pointer = 0xffff8bd54eaa04b8 __d_add entry: 0xffff8bd54eaa04b8 |
a.txt do_filp_open return pointer = 0xffff8bd54eaa04b8 | a.txt

The entry pointer is 0xffff8bd54c33e020 and the string is /mnt/loopfs/a.txt. The lookup key is a.txt with length 5 and hash 3711754354, so the basename is used. The lookup returns NULL, so the cache has no entry for that key. The allocation source pointer is 0xffff8bd54c33e02c, which is 0xffff8bd54c33e020 + 12, so the basename starts after the 12-byte prefix /mnt/loopfs/. The allocation return pointer is 0xffff8bd54eaa04b8, which is new storage. The insert line uses 0xffff8bd54eaa04b8, and the return line matches it, so the file points to that copied name storage.

Derivation: 0xffff8bd54c33e02c - 0xffff8bd54c33e020 = 0xC = 12 "/mnt/loopfs/" length = 12
0xffff8bd54eaa04b8 = __d_alloc return pointer 0xffff8bd54eaa04b8 = __d_add entry pointer
0xffff8bd54eaa04b8 = do_filp_open return pointer

Cache hit: l_e.txt and t_e.txt before deletion.</pre>
<pre><code class="language-c">char n1[] = "l_e.txt";
char n2[] = "/tmp/t_e.txt";

// first opens happen earlier
f[3] = open(n1, O_RDONLY);

// later opens hit cache
f[0] = open(n1, O_RDONLY);
f[1] = open(n2, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: d_lookup entry: hash 440978933 length 7 name l_e.txt d_lookup return:
0xffff8bd5628ba9f8 | l_e.txt

d_lookup entry: hash 1830572521 length 7 name t_e.txt d_lookup return: 0xffff8bd54eaa09f8 | t_e.txt

The lookup for l_e.txt returns 0xffff8bd5628ba9f8, which equals the earlier return pointer for l_e.txt, so the cached dentry is reused. The lookup for t_e.txt returns 0xffff8bd54eaa09f8, which equals the earlier return pointer for t_e.txt, so the cached dentry is reused. The reuse is established by pointer equality.

Cache deletion via unlink.</pre>
<pre><code class="language-c">unlink("l_e.txt");
unlink("/tmp/t_e.txt");</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: d_delete entry: 0xffff8bd5628ba9f8 | l_e.txt d_delete entry: 0xffff8bd54eaa09f8 |
t_e.txt no d_drop entry lines observed in this run

The delete line for l_e.txt uses 0xffff8bd5628ba9f8, which is the cached name pointer shown in the hit. The delete line for t_e.txt uses 0xffff8bd54eaa09f8, which is the cached name pointer shown in the hit. No d_drop line appears in this run, so d_delete is the observed removal path.

Cache eviction via drop_caches.</pre>
<pre><code class="language-c">drop_caches_if_root();
// writes "2\n" to /proc/sys/vm/drop_caches</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: do_filp_open entry pointer = 0xffff8bd54c33e020 | /proc/sys/vm/drop_caches
do_filp_open return pointer = 0xffff8bd6fce05db8 | drop_caches __dentry_kill entry:
0xffff8bd54eaa0e78 | t_m.txt __dentry_kill entry: 0xffff8bd54eaa0278 | l_m.txt __dentry_kill entry:
0xffff8bd5628ba9f8 | l_e.txt __dentry_kill entry: 0xffff8bd54eaa09f8 | t_e.txt __dentry_kill entry:
0xffff8bd54eaa04b8 | a.txt matrix_open (129968): drop_caches: 2

The control file open is visible at 0xffff8bd54c33e020 | /proc/sys/vm/drop_caches and returns 0xffff8bd6fce05db8 | drop_caches, so the eviction trigger is recorded. The eviction lines show __dentry_kill for 0xffff8bd54eaa0e78 (t_m.txt), 0xffff8bd54eaa0278 (l_m.txt), 0xffff8bd5628ba9f8 (l_e.txt), 0xffff8bd54eaa09f8 (t_e.txt), and 0xffff8bd54eaa04b8 (a.txt), so those cached entries are reclaimed in this run.

Cache rebuild after eviction: t_e.txt.</pre>
<pre><code class="language-c">drop_caches_if_root();
sleep(1);

// reopen after eviction
f[0] = open("l_e.txt", O_RDONLY);
f[1] = open("/tmp/t_e.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: d_lookup entry: hash 1830572521 length 7 name t_e.txt __d_alloc entry pointer =
0xffff8bd54c33e025 __d_alloc return pointer = 0xffff8bd54eaa0338 __d_add entry: 0xffff8bd54eaa0338 |
t_e.txt do_filp_open return pointer = 0xffff8bd54eaa0338 | t_e.txt

Restated pre-eviction t_e.txt pointer used for inequality: do_filp_open return pointer =
0xffff8bd54eaa09f8 | t_e.txt

The post-eviction lookup for t_e.txt rebuilds a new pointer. The return pointer is 0xffff8bd54eaa0338, while the pre-eviction pointer is 0xffff8bd54eaa09f8. The inequality 0xffff8bd54eaa0338 != 0xffff8bd54eaa09f8 shows the rebuild produced a new name storage address.

Post-eviction lookup: l_e.txt.</pre>
<pre><code class="language-c">drop_caches_if_root();
sleep(1);

// reopen after eviction
f[0] = open("l_e.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: do_filp_open entry pointer = 0xffff8bd54c33e020 | l_e.txt __d_lookup_rcu entry:
hash 440978933 length 7 name l_e.txt do_filp_open return pointer = 0xffff8bd5450e8278 | l_e.txt

Restated pre-eviction l_e.txt pointer used for inequality: do_filp_open return pointer =
0xffff8bd5628ba9f8 | l_e.txt

The post-eviction lookup uses __d_lookup_rcu with hash 440978933 length 7 name l_e.txt, then returns 0xffff8bd5450e8278. The pre-eviction pointer is 0xffff8bd5628ba9f8, so 0xffff8bd5450e8278 != 0xffff8bd5628ba9f8 records a new return pointer after eviction.

Hash keys used in Run A.</pre>
<pre><code class="language-c">// these names are opened in this run:
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: l_e.txt length 7 hash 440978933 t_e.txt length 7 hash 1830572521 l_m.txt length 7
hash 2166850383 t_m.txt length 7 hash 2543581516 a.txt length 5 hash 3711754354

Each hash line is printed at lookup entry with name and length, so each hash is tied to the exact key shown: l_e.txt (7, 440978933), t_e.txt (7, 1830572521), l_m.txt (7, 2166850383), t_m.txt (7, 2543581516), a.txt (5, 3711754354).

Run B: minimal_open (target_comm=minimal_open)

Long filename: allocation, copy, cache hit.</pre>
<pre><code class="language-c">snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);
sleep(5);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Kernel lines: do_filp_open entry pointer = 0xffff8bd553aca020 |
test_file_very_long_name_to_force_external_allocation_1770412974 d_lookup entry: hash 3341646101
length 64 name test_file_very_long_name_to_force_external_allocation_1770412974 d_lookup return:
NULL __d_alloc entry pointer = 0xffff8bd553aca020 __d_alloc return pointer = 0xffff8bd69ca2a978
__d_add entry: 0xffff8bd69ca2a978 | test_file_very_long_name_to_force_external_allocation_1770412974
do_filp_open return pointer = 0xffff8bd69ca2a978 |
test_file_very_long_name_to_force_external_allocation_1770412974 d_lookup return: 0xffff8bd69ca2a978
| test_file_very_long_name_to_force_external_allocation_1770412974

The entry pointer is 0xffff8bd553aca020 and the string is the full long filename, so the kernel copy is fixed to that address. The lookup key is the long filename with length 64 and hash 3341646101, so the key and length are explicit. The lookup returns NULL, so the cache has no entry for that key on first use. The allocation source pointer is 0xffff8bd553aca020, which equals the string pointer, so the copy source is the start of the long name. The allocation return pointer is 0xffff8bd69ca2a978, which is new storage. The insert line uses 0xffff8bd69ca2a978, and the return line matches it. The later d_lookup return line also returns 0xffff8bd69ca2a978, so the cache hit reuses the same pointer. The equality chain is 0xffff8bd69ca2a978 = __d_alloc return = __d_add entry = do_filp_open return = d_lookup return.

Memcpy of name into dentry storage: t_e.txt, a.txt, long filename.

Cache build-up (insert): t_e.txt, t_m.txt, l_m.txt, a.txt, post-eviction t_e.txt, long filename.

Cache hit: l_e.txt, t_e.txt, long filename.

Cache miss: t_e.txt, t_m.txt, l_m.txt, a.txt, long filename.

Cache deletion: l_e.txt, t_e.txt.

Cache eviction: l_e.txt, t_e.txt, t_m.txt, l_m.txt, a.txt.

Cache rebuild: t_e.txt.

Full Proofs (No Data Removed)

Proof 1. memcpy of filename into dentry storage.

Evidence (t_e.txt): __d_alloc entry pointer = 0xffff8bd54c33e025 __d_alloc return pointer =
0xffff8bd54eaa09f8 __d_add entry: 0xffff8bd54eaa09f8 | t_e.txt do_filp_open return pointer =
0xffff8bd54eaa09f8 | t_e.txt

Derivation: 0xffff8bd54eaa09f8 = __d_alloc return pointer 0xffff8bd54eaa09f8 = __d_add entry pointer
0xffff8bd54eaa09f8 = do_filp_open return pointer

Evidence (a.txt): __d_alloc entry pointer = 0xffff8bd54c33e02c __d_alloc return pointer =
0xffff8bd54eaa04b8 __d_add entry: 0xffff8bd54eaa04b8 | a.txt do_filp_open return pointer =
0xffff8bd54eaa04b8 | a.txt

Derivation: 0xffff8bd54eaa04b8 = __d_alloc return pointer 0xffff8bd54eaa04b8 = __d_add entry pointer
0xffff8bd54eaa04b8 = do_filp_open return pointer

Evidence (long filename): __d_alloc entry pointer = 0xffff8bd553aca020 __d_alloc return pointer =
0xffff8bd69ca2a978 __d_add entry: 0xffff8bd69ca2a978 |
test_file_very_long_name_to_force_external_allocation_1770412974 do_filp_open return pointer =
0xffff8bd69ca2a978 | test_file_very_long_name_to_force_external_allocation_1770412974

Derivation: 0xffff8bd69ca2a978 = __d_alloc return pointer 0xffff8bd69ca2a978 = __d_add entry pointer
0xffff8bd69ca2a978 = do_filp_open return pointer

Proof 2. Cache build-up (insert) on miss.

Evidence: d_lookup return: NULL __d_add entry: 0xffff8bd54eaa09f8 | t_e.txt

d_lookup return: NULL __d_add entry: 0xffff8bd54eaa0e78 | t_m.txt

d_lookup return: NULL __d_add entry: 0xffff8bd54eaa0278 | l_m.txt

d_lookup return: NULL __d_add entry: 0xffff8bd54eaa04b8 | a.txt

d_lookup return: NULL __d_add entry: 0xffff8bd69ca2a978 |
test_file_very_long_name_to_force_external_allocation_1770412974

Proof 3. Cache miss.

Evidence: d_lookup return: NULL (t_e.txt) d_lookup return: NULL (t_m.txt) d_lookup return: NULL
(l_m.txt) d_lookup return: NULL (a.txt) d_lookup return: NULL (long filename)

Proof 4. Cache hit.

Evidence: d_lookup entry: hash 440978933 length 7 name l_e.txt d_lookup return: 0xffff8bd5628ba9f8 |
l_e.txt

d_lookup entry: hash 1830572521 length 7 name t_e.txt d_lookup return: 0xffff8bd54eaa09f8 | t_e.txt

d_lookup entry: hash 3341646101 length 64 name
test_file_very_long_name_to_force_external_allocation_1770412974 d_lookup return pointer =
0xffff8bd69ca2a978

Proof 5. Cache delete.

Evidence: d_delete entry: 0xffff8bd5628ba9f8 | l_e.txt d_delete entry: 0xffff8bd54eaa09f8 | t_e.txt

Proof 5b. Cache eviction (drop_caches).

Evidence: do_filp_open entry pointer = 0xffff8bd54c33e020 | /proc/sys/vm/drop_caches do_filp_open
return pointer = 0xffff8bd6fce05db8 | drop_caches __dentry_kill entry: 0xffff8bd5628ba9f8 | l_e.txt
__dentry_kill entry: 0xffff8bd54eaa09f8 | t_e.txt __dentry_kill entry: 0xffff8bd54eaa0e78 | t_m.txt
__dentry_kill entry: 0xffff8bd54eaa0278 | l_m.txt __dentry_kill entry: 0xffff8bd54eaa04b8 | a.txt

Proof 5c. Cache rebuild after eviction (t_e.txt).

Evidence: d_lookup entry: hash 1830572521 length 7 name t_e.txt d_lookup return: NULL __d_alloc
entry pointer = 0xffff8bd54c33e025 __d_alloc return pointer = 0xffff8bd54eaa0338 __d_add entry:
0xffff8bd54eaa0338 | t_e.txt do_filp_open return pointer = 0xffff8bd54eaa0338 | t_e.txt

Proof 6. Long filename behavior.

Evidence: d_lookup entry: hash 3341646101 length 64 name
test_file_very_long_name_to_force_external_allocation_1770412974 d_lookup return: NULL __d_alloc
entry pointer = 0xffff8bd553aca020 __d_alloc return pointer = 0xffff8bd69ca2a978 __d_add entry:
0xffff8bd69ca2a978 | test_file_very_long_name_to_force_external_allocation_1770412974 do_filp_open
return pointer = 0xffff8bd69ca2a978 |
test_file_very_long_name_to_force_external_allocation_1770412974

Proof 7. Short filename behavior.

Evidence: d_lookup entry: hash 3711754354 length 5 name a.txt d_lookup return: NULL __d_alloc entry
pointer = 0xffff8bd54c33e02c __d_alloc return pointer = 0xffff8bd54eaa04b8 __d_add entry:
0xffff8bd54eaa04b8 | a.txt do_filp_open return pointer = 0xffff8bd54eaa04b8 | a.txt

Derivation: 0xffff8bd54c33e02c - 0xffff8bd54c33e020 = 0xC = 12 "/mnt/loopfs/" length = 12

Wide-Screen Trace Appendix

Full Trace A (matrix_open, latest run)

Scope note: this trace lists the open sequence after the first drop_caches call. The earlier
creat(...) calls also execute do_filp_open and appear in dmesg, but they are not repeated here to
keep the step list aligned to the open sequence used for the claims.

#1. Call. do_filp_open entry. Values: name pointer 0xffff8bd54c33e020, name string /tmp/t_e.txt.
Data: user-space open("/tmp/t_e.txt") reached kernel. Work: begin lookup for basename t_e.txt.
Errors: none. Caller line: not recorded. Current line: not recorded. Resume: will return to caller
with file pointer. #2. Call. __d_lookup_rcu entry. Values: hash 2802308728, length 3, name
tmp/t_e.txt. Data: RCU path checks tmp/t_e.txt prefix. Work: prefix lookup. Errors: none. Caller
line: not recorded. Current line: not recorded. Resume: returns to lookup path. #3. Call.
__d_lookup_rcu entry. Values: hash 1830572521, length 7, name t_e.txt. Data: RCU path checks
basename. Work: fast path lookup. Errors: none. Caller line: not recorded. Current line: not
recorded. Resume: returns to lookup path. #4. Call. d_lookup entry. Values: hash 1830572521, length
7, name t_e.txt. Data: exact lookup key. Work: slow path lookup. Errors: none. Caller line: not
recorded. Current line: not recorded. Resume: returns with hit/miss. #5. Return. d_lookup return.
Values: NULL. Data: cache miss. Work: miss triggers allocation. Errors: none. Caller line: not
recorded. Current line: not recorded. Resume: control continues to allocate dentry. #6. Call.
__d_alloc entry. Values: name pointer 0xffff8bd54c33e025. Data: points to basename start in
/tmp/t_e.txt. Work: allocate dentry name storage and copy. Errors: none. Caller line: not recorded.
Current line: not recorded. Resume: returns new dentry pointer. #7. Return. __d_alloc return.
Values: name pointer 0xffff8bd54eaa09f8. Data: newly allocated dentry name storage for t_e.txt.
Work: allocate completed. Errors: none. Caller line: not recorded. Current line: not recorded.
Resume: control continues to insert into dcache. #8. Call. __d_add entry. Values: name pointer
0xffff8bd54eaa09f8, name t_e.txt. Data: inserting new dentry. Work: insert into dcache hash. Errors:
none. Caller line: not recorded. Current line: not recorded. Resume: returns to open path. #9.
Return. do_filp_open. Values: name pointer 0xffff8bd54eaa09f8, name t_e.txt. Data: returned file
points to newly allocated name storage. Work: open completes. Errors: none. Caller line: not
recorded. Current line: not recorded. Resume: returns to user space. #10. Call. do_filp_open entry.
Values: name pointer 0xffff8bd54c33e020, name /tmp/t_m.txt. Data: user-space open of missing file.
Work: begin lookup for basename t_m.txt. Errors: none. Caller line: not recorded. Current line: not
recorded. Resume: will return with error or file. #11. Call. __d_lookup_rcu entry. Values: hash
2802308728, length 3, name tmp/t_m.txt. Data: RCU prefix lookup. Work: prefix lookup. Errors: none.
Caller line: not recorded. Current line: not recorded. Resume: returns to lookup path. #12. Call.
__d_lookup_rcu entry. Values: hash 2543581516, length 7, name t_m.txt. Data: RCU basename lookup.
Work: fast path lookup. Errors: none. Caller line: not recorded. Current line: not recorded. Resume:
returns to lookup path. #13. Call. d_lookup entry. Values: hash 2543581516, length 7, name t_m.txt.
Data: exact lookup key. Work: slow path lookup. Errors: none. Caller line: not recorded. Current
line: not recorded. Resume: returns with hit/miss. #14. Return. d_lookup return. Values: NULL. Data:
cache miss. Work: miss triggers allocation. Errors: none. Caller line: not recorded. Current line:
not recorded. Resume: control continues to allocate dentry. #15. Call. __d_alloc entry. Values: name
pointer 0xffff8bd54c33e025. Data: points to basename start in /tmp/t_m.txt. Work: allocate dentry
name storage and copy. Errors: none. Caller line: not recorded. Current line: not recorded. Resume:
returns new dentry pointer. #16. Return. __d_alloc return. Values: name pointer 0xffff8bd54eaa0e78.
Data: newly allocated dentry name storage for t_m.txt. Work: allocation completed. Errors: none.
Caller line: not recorded. Current line: not recorded. Resume: control continues to insert. #17.
Call. __d_add entry. Values: name pointer 0xffff8bd54eaa0e78, name t_m.txt. Data: inserting dentry.
Work: insert into dcache hash. Errors: none. Caller line: not recorded. Current line: not recorded.
Resume: returns to open path. #18. Call. do_filp_open entry. Values: name pointer
0xffff8bd54c33e020, name l_m.txt. Data: user-space open of missing file. Work: begin lookup for
basename l_m.txt. Errors: none. Caller line: not recorded. Current line: not recorded. Resume: will
return with error or file. #19. Call. __d_lookup_rcu entry. Values: hash 2166850383, length 7, name
l_m.txt. Data: RCU lookup. Work: fast path lookup. Errors: none. Caller line: not recorded. Current
line: not recorded. Resume: returns to lookup path. #20. Call. d_lookup entry. Values: hash
2166850383, length 7, name l_m.txt. Data: exact lookup key. Work: slow path lookup. Errors: none.
Caller line: not recorded. Current line: not recorded. Resume: returns with hit/miss. #21. Return.
d_lookup return. Values: NULL. Data: cache miss. Work: miss triggers allocation. Errors: none.
Caller line: not recorded. Current line: not recorded. Resume: control continues to allocate dentry.
#22. Call. __d_alloc entry. Values: name pointer 0xffff8bd54c33e020. Data: points to basename start
in l_m.txt. Work: allocate dentry name storage and copy. Errors: none. Caller line: not recorded.
Current line: not recorded. Resume: returns new dentry pointer. #23. Return. __d_alloc return.
Values: name pointer 0xffff8bd54eaa0278. Data: newly allocated dentry name storage for l_m.txt.
Work: allocation completed. Errors: none. Caller line: not recorded. Current line: not recorded.
Resume: control continues to insert. #24. Call. __d_add entry. Values: name pointer
0xffff8bd54eaa0278, name l_m.txt. Data: inserting dentry. Work: insert into dcache hash. Errors:
none. Caller line: not recorded. Current line: not recorded. Resume: returns to open path. #25.
Call. do_filp_open entry. Values: name pointer 0xffff8bd54c33e020, name /mnt/loopfs/a.txt. Data:
user-space open on loopback ext2. Work: begin lookup for basename a.txt. Errors: none. Caller line:
not recorded. Current line: not recorded. Resume: will return with file pointer. #26. Call.
__d_lookup_rcu entry. Values: hash 4289119505, length 3, name mnt/loopfs/a.txt. Data: RCU prefix
lookup. Work: prefix lookup. Errors: none. Caller line: not recorded. Current line: not recorded.
Resume: returns to lookup path. #27. Call. __d_lookup_rcu entry. Values: hash 1683324524, length 6,
name loopfs/a.txt. Data: RCU intermediate prefix lookup. Work: prefix lookup. Errors: none. Caller
line: not recorded. Current line: not recorded. Resume: returns to lookup path. #28. Call.
__d_lookup_rcu entry. Values: hash 3711754354, length 5, name a.txt. Data: RCU basename lookup.
Work: fast path lookup. Errors: none. Caller line: not recorded. Current line: not recorded. Resume:
returns to lookup path. #29. Call. d_lookup entry. Values: hash 3711754354, length 5, name a.txt.
Data: exact lookup key. Work: slow path lookup. Errors: none. Caller line: not recorded. Current
line: not recorded. Resume: returns with hit/miss. #30. Return. d_lookup return. Values: NULL. Data:
cache miss. Work: miss triggers allocation. Errors: none. Caller line: not recorded. Current line:
not recorded. Resume: control continues to allocate dentry. #31. Call. __d_alloc entry. Values: name
pointer 0xffff8bd54c33e02c. Data: points to basename start in /mnt/loopfs/a.txt. Work: allocate
dentry name storage and copy. Errors: none. Caller line: not recorded. Current line: not recorded.
Resume: returns new dentry pointer. #32. Return. __d_alloc return. Values: name pointer
0xffff8bd54eaa04b8. Data: newly allocated dentry name storage for a.txt. Work: allocation completed.
Errors: none. Caller line: not recorded. Current line: not recorded. Resume: control continues to
insert. #33. Call. __d_add entry. Values: name pointer 0xffff8bd54eaa04b8, name a.txt. Data:
inserting new dentry. Work: insert into dcache hash. Errors: none. Caller line: not recorded.
Current line: not recorded. Resume: returns to open path. #34. Return. do_filp_open. Values: name
pointer 0xffff8bd54eaa04b8, name a.txt. Data: returned file points to newly allocated name storage.
Work: open completes. Errors: none. Caller line: not recorded. Current line: not recorded. Resume:
returns to user space. #35. Call. do_filp_open entry. Values: name pointer 0xffff8bd54c33e020, name
l_e.txt. Data: user-space open of existing file. Work: lookup for l_e.txt. Errors: none. Caller
line: not recorded. Current line: not recorded. Resume: will return with file pointer. #36. Call.
__d_lookup_rcu entry. Values: hash 440978933, length 7, name l_e.txt. Data: RCU lookup. Work: fast
path lookup. Errors: none. Caller line: not recorded. Current line: not recorded. Resume: returns to
lookup path. #37. Return. d_lookup return. Values: pointer 0xffff8bd5628ba9f8, name l_e.txt. Data:
cache hit. Work: reuse cached dentry. Errors: none. Caller line: not recorded. Current line: not
recorded. Resume: control returns to open path. #38. Return. do_filp_open. Values: name pointer
0xffff8bd5628ba9f8, name l_e.txt. Data: open returns cached dentry name storage. Work: open
completes. Errors: none. Caller line: not recorded. Current line: not recorded. Resume: returns to
user space. #39. Call. d_delete entry. Values: pointer 0xffff8bd5628ba9f8, name l_e.txt. Data:
unlink removal. Work: delete dentry from hash. Errors: none. Caller line: not recorded. Current
line: not recorded. Resume: returns to unlink path. #40. Call. d_delete entry. Values: pointer
0xffff8bd54eaa09f8, name t_e.txt. Data: unlink removal. Work: delete dentry from hash. Errors: none.
Caller line: not recorded. Current line: not recorded. Resume: returns to unlink path. #41. Call.
do_filp_open entry. Values: name pointer 0xffff8bd54c33e020, name /proc/sys/vm/drop_caches. Data:
control write to drop caches. Work: open drop_caches for eviction. Errors: none. Caller line: not
recorded. Current line: not recorded. Resume: returns to user space. #42. Return. do_filp_open.
Values: name pointer 0xffff8bd6fce05db8, name drop_caches. Data: control file opened. Work: enables
eviction. Errors: none. Caller line: not recorded. Current line: not recorded. Resume: returns to
user space. #43. Call. __dentry_kill entry. Values: pointer 0xffff8bd5628ba9f8, name l_e.txt. Data:
eviction of cached dentry. Work: reclaim dentry. Errors: none. Caller line: not recorded. Current
line: not recorded. Resume: returns to shrinker. #44. Call. __dentry_kill entry. Values: pointer
0xffff8bd54eaa09f8, name t_e.txt. Data: eviction of cached dentry. Work: reclaim dentry. Errors:
none. Caller line: not recorded. Current line: not recorded. Resume: returns to shrinker. #45. Call.
do_filp_open entry. Values: name pointer 0xffff8bd54c33e020, name l_e.txt. Data: post-eviction open.
Work: lookup after eviction. Errors: none. Caller line: not recorded. Current line: not recorded.
Resume: returns with file pointer. #46. Call. __d_lookup_rcu entry. Values: hash 440978933, length
7, name l_e.txt. Data: RCU lookup after eviction. Work: fast path lookup. Errors: none. Caller line:
not recorded. Current line: not recorded. Resume: returns to open path. #47. Return. do_filp_open.
Values: name pointer 0xffff8bd5450e8278, name l_e.txt. Data: post-eviction return pointer differs
from pre-eviction pointer 0xffff8bd5628ba9f8. Work: open completes. Errors: none. Caller line: not
recorded. Current line: not recorded. Resume: returns to user space. #48. Call. do_filp_open entry.
Values: name pointer 0xffff8bd54c33e020, name /tmp/t_e.txt. Data: post-eviction open. Work: lookup
after eviction. Errors: none. Caller line: not recorded. Current line: not recorded. Resume: returns
with file pointer. #49. Call. d_lookup entry. Values: hash 1830572521, length 7, name t_e.txt. Data:
lookup key. Work: slow path lookup. Errors: none. Caller line: not recorded. Current line: not
recorded. Resume: returns with hit/miss. #50. Return. d_lookup return. Values: NULL. Data: miss
post-eviction. Work: triggers rebuild. Errors: none. Caller line: not recorded. Current line: not
recorded. Resume: control continues to allocate. #51. Call. __d_alloc entry. Values: name pointer
0xffff8bd54c33e025. Data: basename pointer. Work: allocate new name storage. Errors: none. Caller
line: not recorded. Current line: not recorded. Resume: returns new dentry pointer. #52. Return.
__d_alloc return. Values: name pointer 0xffff8bd54eaa0338. Data: new name storage for t_e.txt. Work:
allocation completed. Errors: none. Caller line: not recorded. Current line: not recorded. Resume:
control continues to insert. #53. Call. __d_add entry. Values: name pointer 0xffff8bd54eaa0338, name
t_e.txt. Data: insert new dentry. Work: insert into dcache. Errors: none. Caller line: not recorded.
Current line: not recorded. Resume: returns to open path. #54. Return. do_filp_open. Values: name
pointer 0xffff8bd54eaa0338, name t_e.txt. Data: rebuilt pointer differs from pre-eviction pointer
0xffff8bd54eaa09f8. Work: open completes. Errors: none. Caller line: not recorded. Current line: not
recorded. Resume: returns to user space.

Symbol availability proof (from this machine)

Kernel headers and sources:

uname -r: 6.14.0-37-generic /usr/src contains linux-headers-6.14.0-37-generic /usr/src contains
linux-source-6.8.0

kptr_restrict: 1 perf_event_paranoid: 4

Symbols in /proc/kallsyms:

__d_add: ffffffff89beaaa0 (local symbol, type t) d_add: ffffffff89beaca0 (global symbol, type T)
d_rehash: ffffffff89bea3e0 (global symbol, type T) d_add_ci: ffffffff89becf20 (global symbol, type
T) full_name_hash: ffffffff89bd5010 (global symbol, type T)

Why __d_add is not in available_filter_functions: available_filter_functions is the ftrace function
list, not a full symbol list. It only includes functions that ftrace exposes (non-inlined,
traceable, and globally visible). __d_add is present as a local symbol in kallsyms, so kprobe can
attach to it, but ftrace does not list it.

What We Failed To Observe And Why

1. We did not observe a __d_add line for l_e.txt in the post-eviction rebuild phase. The post-eviction lookup is visible on the RCU path and returns a new pointer, but an explicit insert line for l_e.txt was not printed in this run. This is why the l_e.txt section is phrased as a post-eviction lookup, not an explicit insert.
2. We did not observe any d_drop entry lines for these names. The d_delete lines are present in the data, but d_drop did not fire for these paths in this run.
3. We did not observe any full_name_hash return lines in this run. The full_name_hash kretprobe is registered, but the function may be inlined or bypassed in this path on this kernel build. Hash values are still recorded via d_lookup entry, __d_lookup entry, and __d_lookup_rcu entry, which report the key hash and length used.

Proofs from the latest run (commands + results):</pre>
<pre><code class="language-text">sudo dmesg | rg -n "__d_add entry: .*l_e.txt"
&lt;no output&gt;

sudo dmesg | rg -n "d_drop entry"
&lt;no output&gt;

sudo dmesg | rg -n "full_name_hash return"
&lt;no output&gt;</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Post-eviction l_e.txt lookup/return is visible even without __d_add:</pre>
<pre><code class="language-text">sudo dmesg | rg -n "__d_lookup_rcu entry:.*l_e.txt|\[O\] OUT: .*l_e.txt"
15:[33032.402797] __d_lookup_rcu entry: hash 440978933 length 7 name l_e.txt
17:[33032.402853] [O] OUT: 0xffff8bd54e0c74b8 | l_e.txt
35:[33033.423905] __d_lookup_rcu entry: hash 440978933 length 7 name l_e.txt
37:[33033.423931] [O] OUT: 0xffff8bd5628ba9f8 | l_e.txt
149:[33036.444278] __d_lookup_rcu entry: hash 440978933 length 7 name l_e.txt
151:[33036.444304] [O] OUT: 0xffff8bd5450e8278 | l_e.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Explanation: the repeated __d_lookup_rcu entries show the lookup key for l_e.txt after eviction, and the [O] OUT lines show the return pointer seen by do_filp_open. The change from 0xffff8bd54e0c74b8 and 0xffff8bd5628ba9f8 to 0xffff8bd5450e8278 records a new return pointer after eviction without an __d_add line in this run.</pre>
  </div>

</body>

</html>
