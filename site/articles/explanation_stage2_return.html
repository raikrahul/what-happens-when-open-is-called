<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">Abstract

We measure the filename string as it passes through do_filp_open and the dentry cache. We record input pointers, copy source and destination, return pointers, cache hits, hash values, and explicit cache insert events via __d_add. We also add a loopback filesystem case with a short name to show a distinct filesystem path. The results show that do_filp_open returns a pointer to the dentry name. On cache miss, __d_alloc copies the name and the return pointer equals the copy destination, and __d_add shows the insert into the dcache. On cache hit, d_lookup returns the same pointer as the prior return. Hash values and lengths printed at d_lookup entry prove the lookup keys used for each name.

Prior Work

Stage 1: https://raikrahul.github.io/what-happens-when-open-is-called/stage1.html
Stage 2 Entry: https://raikrahul.github.io/what-happens-when-open-is-called/stage2.html
Worksheet: https://raikrahul.github.io/what-happens-when-open-is-called/articles/worksheet_stage2_return.html

Introduction

The goal of this stage is concrete: identify where the filename string ends up at return time and prove it with data. The measurement must include both allocation and cache paths and must show the hash values used for lookup. The test programs are designed to produce both paths in one run, and a loopback filesystem test adds a distinct filesystem path and a short name.

Methods

User-space programs:

minimal_open.c
```c
snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);
sleep(5);
```

matrix_open.c
```c
close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
```

Per-line purpose

close(creat("l_e.txt", 0644)); creates a local file so the first open can hit a real inode in the current directory.
close(creat("/tmp/t_e.txt", 0644)); creates a file under /tmp so the path has a prefix and produces a basename shift in the copy source pointer.
open("l_e.txt", O_RDONLY); first open of an existing local file, intended to show allocation or cache miss behavior.
open("/tmp/t_e.txt", O_RDONLY); first open of an existing /tmp file, intended to show basename copy and allocation.
open("/tmp/t_m.txt", O_RDONLY); open of a missing /tmp file, intended to show an error path with no returned file pointer.
open("l_e.txt", O_RDONLY); second open of the same local file, intended to show a cache hit and pointer reuse.
open("l_m.txt", O_RDONLY); open of a missing local file, intended to show a second error path.
open("/mnt/loopfs/a.txt", O_RDONLY); open of a file on a loopback ext2 filesystem, intended to show the same flow on a different filesystem and a short name.
open("l_e.txt", O_RDONLY); third open of the local file, intended to show repeated cache hit stability.

Loopback filesystem test:

- 64M loopback file formatted as ext2
- mounted at /mnt/loopfs
- a.txt created, sync, unmount, remount

Probe map and observed fields:

- do_filp_open entry: input filename pointer
- __d_alloc entry: copy source pointer
- __d_alloc return: copy destination pointer
- do_filp_open return: returned struct file name pointer
- d_lookup entry: hash value, length, and name string
- d_lookup return: cache hit name pointer
- __d_add entry: dentry name pointer at insert into dcache

Memcpy proof (kernel source)

File: /usr/src/linux-source-6.8.0/fs/dcache.c:1660
memcpy(dname, name-&gt;name, name-&gt;len);

Per-probe purpose

do_filp_open entry: capture the input name pointer before any lookup or allocation. This is the kernel-side name pointer used for the open.
__d_alloc entry: capture the source pointer used for name copying into a new dentry. This is the copy source.
__d_alloc return: capture the destination pointer for the copied name in the new dentry. This is the copy destination.
do_filp_open return: capture the name pointer referenced by the returned struct file. This is the return pointer we compare against copies and cache hits.
d_lookup entry: capture the hash value, length, and name used as the lookup key. This shows which exact string is hashed for lookup.
d_lookup return: capture the name pointer of a cached dentry on hit. This is the pointer reused on cache hits.
__d_add entry: capture the moment the new dentry name is inserted into the dcache. This is the cache build-up proof.

ASCII diagram: allocation path
```text
user string
    |
    v
do_filp_open entry
    |
    v
__d_alloc entry (copy source)
    |
    v
__d_alloc return (copy destination)
    |
    v
do_filp_open return
```

ASCII diagram: cache hit path
```text
user string
    |
    v
do_filp_open entry
    |
    v
d_lookup return
    |
    v
do_filp_open return
```

ASCII diagram: hash lookup
```text
name string + length
        |
        v
     full_name_hash
        |
        v
   hash value (H)
        |
        v
  d_lookup bucket
```

Results

Pointers (minimal_open, fresh run):

do_filp_open entry pointer = 0xffff8bd546396020
__d_alloc entry pointer = 0xffff8bd546396020
__d_alloc return pointer = 0xffff8bd61ceac618
do_filp_open return pointer = 0xffff8bd61ceac618
d_lookup return pointer = 0xffff8bd61ceac618

Pointers (matrix_open with loopback, fresh run):

l_e.txt first open:

do_filp_open entry pointer = 0xffff8bd54d6ac020
__d_alloc entry pointer = 0xffff8bd54d6ac020
__d_alloc return pointer = 0xffff8bd7a2123f38
do_filp_open return pointer = 0xffff8bd7a2123f38

/tmp/t_e.txt first open:

do_filp_open entry pointer = 0xffff8bd54d6ac020
__d_alloc entry pointer = 0xffff8bd54d6ac025
__d_alloc return pointer = 0xffff8bd7a2123878
do_filp_open return pointer = 0xffff8bd7a2123878

l_m.txt:

do_filp_open entry pointer = 0xffff8bd54d6ac020
do_filp_open return pointer not observed
__d_alloc not observed

/mnt/loopfs/a.txt:

do_filp_open entry pointer = 0xffff8bd54d6ac020
do_filp_open return pointer = 0xffff8bd645a969f8
__d_alloc not observed

cache hits after 2 seconds:

d_lookup return pointer = 0xffff8bd7a2123f38 for l_e.txt
d_lookup return pointer = 0xffff8bd7a2123878 for t_e.txt

Hashes (dmesg, fresh run):

matrix_open:

d_lookup entry: hash 399720033 length 7 name l_e.txt
d_lookup entry: hash 1830572521 length 7 name t_e.txt
no d_lookup hash line observed for a.txt in this run

minimal_open:

d_lookup entry: hash 1147649438 length 64 name test_file_very_long_name_to_force_external_allocation_1770402889

hash_open:

d_lookup entry: hash 1675155717 length 7 name l_m.txt
d_lookup entry: hash 2543581516 length 7 name t_m.txt

Numeric checks:

0xffff8bd54d6ac025 - 0xffff8bd54d6ac020 = 0x5 = 5
"/tmp/" length = 5

Cache hit proof (same pointer reused)

l_e.txt:
do_filp_open return pointer = 0xffff8bd7a2123f38
d_lookup return pointer = 0xffff8bd7a2123f38

t_e.txt:
do_filp_open return pointer = 0xffff8bd7a2123878
d_lookup return pointer = 0xffff8bd7a2123878

Cache miss proof (allocation path observed)

l_e.txt first open:
do_filp_open entry pointer = 0xffff8bd54d6ac020
d_lookup return pointer = NULL
__d_alloc entry pointer = 0xffff8bd54d6ac020
__d_alloc return pointer = 0xffff8bd7a2123f38
do_filp_open return pointer = 0xffff8bd7a2123f38

/tmp/t_e.txt first open:
do_filp_open entry pointer = 0xffff8bd54d6ac020
d_lookup return pointer = NULL
__d_alloc entry pointer = 0xffff8bd54d6ac025
__d_alloc return pointer = 0xffff8bd7a2123878
do_filp_open return pointer = 0xffff8bd7a2123878

Cache build-up proof (insert into dcache)

l_e.txt:
__d_add entry pointer = 0xffff8bd7a2123f38

t_e.txt:
__d_add entry pointer = 0xffff8bd7a2123878
Hash keys:

l_e.txt with length 7 -&gt; 399720033
t_e.txt with length 7 -&gt; 1830572521
l_m.txt with length 7 -&gt; 1675155717
t_m.txt with length 7 -&gt; 2543581516
test_file_very_long_name_to_force_external_allocation_1770402889 with length 64 -&gt; 1147649438
no hash key printed for a.txt in this run

Discussion

The allocation path is shown by a copy source pointer and copy destination pointer appearing and the return pointer equaling the copy destination. The cache build-up is shown by __d_add inserting the same dentry name pointer that __d_alloc produced. The cache hit path is shown by the cache hit pointer equaling the earlier return pointer for the same name. The /tmp case shows a 5 byte offset between the input pointer and the copy source pointer, matching the /tmp/ prefix and isolating the basename. The loopback ext2 case shows that the same flow applies across a different filesystem with a short name. The missing name cases show an input pointer but no return pointer, so no struct file is returned, and no cache hit is reported for those names.

Conclusion

The returned struct file pointer equals the dentry name pointer. On allocation, __d_alloc copies the name and the return pointer equals the copy destination, and __d_add shows the insert into dcache. On cache hit, d_lookup returns the same pointer observed earlier. Hash values and lengths printed at d_lookup entry prove that each lookup hashes the exact key string used for that path.</pre>
  </div>

</body>

</html>