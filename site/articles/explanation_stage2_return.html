<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">Abstract

We measure the filename string as it passes through do_filp_open and the dentry cache. We record input pointers, copy source and destination, return pointers, cache hits, hash values, explicit cache insert events via __d_add, and cache removal events via d_delete and __dentry_kill. We also add a loopback filesystem case with a short name to show a distinct filesystem path and use drop_caches to force eviction. The results show that do_filp_open returns a pointer to the dentry name. On cache miss, __d_alloc copies the name and the return pointer equals the copy destination, and __d_add shows the insert into the dcache. On cache hit, d_lookup returns the same pointer as the prior return. d_delete and __dentry_kill show deletion and eviction. Hash values and lengths printed at d_lookup entry prove the lookup keys used for each name.

Prior Work

Stage 1: https://raikrahul.github.io/what-happens-when-open-is-called/stage1.html
Stage 2 Entry: https://raikrahul.github.io/what-happens-when-open-is-called/stage2.html
Worksheet: https://raikrahul.github.io/what-happens-when-open-is-called/articles/worksheet_stage2_return.html

Introduction

The goal of this stage is concrete: identify where the filename string ends up at return time and prove it with data. The measurement must include both allocation and cache paths and must show the hash values used for lookup. The test programs are designed to produce both paths in one run, and a loopback filesystem test adds a distinct filesystem path and a short name.

Methods

User-space programs:

minimal_open.c
```c
snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);
sleep(5);
```

matrix_open.c
```c
close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
sleep(2);
close_all();
unlink("l_e.txt");
unlink("/tmp/t_e.txt");
close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
``` 

Per-line purpose

close(creat("l_e.txt", 0644)); creates a local file so the first open can hit a real inode in the current directory.
close(creat("/tmp/t_e.txt", 0644)); creates a file under /tmp so the path has a prefix and produces a basename shift in the copy source pointer.
drop_caches_if_root(); evicts dentry cache entries so the next opens show cache misses and inserts.
sleep(1); allows eviction to complete before the first opens.
open("l_e.txt", O_RDONLY); first open of an existing local file, intended to show allocation or cache miss behavior.
open("/tmp/t_e.txt", O_RDONLY); first open of an existing /tmp file, intended to show basename copy and allocation.
open("/tmp/t_m.txt", O_RDONLY); open of a missing /tmp file, intended to show an error path with no returned file pointer.
open("l_e.txt", O_RDONLY); second open of the same local file, intended to show a cache hit and pointer reuse.
open("l_m.txt", O_RDONLY); open of a missing local file, intended to show a second error path.
open("/mnt/loopfs/a.txt", O_RDONLY); open of a file on a loopback ext2 filesystem, intended to show the same flow on a different filesystem and a short name.
open("l_e.txt", O_RDONLY); third open of the local file, intended to show repeated cache hit stability.
sleep(2); allows cache hit probes to run before deletion.
close_all(); releases file descriptors so dentries can be deleted or evicted.
unlink("l_e.txt"); deletes the local file name, intended to show d_delete for that dentry.
unlink("/tmp/t_e.txt"); deletes the /tmp file name, intended to show d_delete for that dentry.
close(creat("l_e.txt", 0644)); recreates the local file name for rebuild tests.
close(creat("/tmp/t_e.txt", 0644)); recreates the /tmp file name for rebuild tests.
open("l_e.txt", O_RDONLY); reopen after deletion to observe reuse or rebuild.
open("/tmp/t_e.txt", O_RDONLY); reopen after deletion to observe reuse or rebuild.
drop_caches_if_root(); forces eviction to prove rebuild after eviction.
sleep(1); allows eviction to complete.
open("l_e.txt", O_RDONLY); reopen after eviction to observe rebuild.
open("/tmp/t_e.txt", O_RDONLY); reopen after eviction to observe rebuild.

Loopback filesystem test:

- 64M loopback file formatted as ext2
- mounted at /mnt/loopfs
- a.txt created, sync, unmount, remount

Symbol availability proof (from this machine)

Kernel headers and sources:

uname -r: 6.14.0-37-generic
/usr/src contains linux-headers-6.14.0-37-generic
/usr/src contains linux-source-6.8.0

kptr_restrict: 1
perf_event_paranoid: 4

Symbols in /proc/kallsyms:

__d_add: ffffffff89beaaa0 (local symbol, type t)
d_add: ffffffff89beaca0 (global symbol, type T)
d_rehash: ffffffff89bea3e0 (global symbol, type T)
d_add_ci: ffffffff89becf20 (global symbol, type T)
full_name_hash: ffffffff89bd5010 (global symbol, type T)

Why __d_add is not in available_filter_functions:
available_filter_functions is the ftrace function list, not a full symbol list. It only includes functions that ftrace exposes (non-inlined, traceable, and globally visible). __d_add is present as a local symbol in kallsyms, so kprobe can attach to it, but ftrace does not list it.

Probe map and observed fields:

- do_filp_open entry: input filename pointer
- __d_alloc entry: copy source pointer
- __d_alloc return: copy destination pointer
- do_filp_open return: returned struct file name pointer
- d_lookup entry: hash value, length, and name string
- d_lookup return: cache hit name pointer
- __d_add entry: dentry name pointer at insert into dcache
- d_delete entry: dentry name pointer at unlink removal
- __dentry_kill entry: dentry name pointer at eviction via drop_caches

Memcpy proof (kernel source)

File: /usr/src/linux-source-6.8.0/fs/dcache.c:1660
memcpy(dname, name-&gt;name, name-&gt;len);

Per-probe purpose

do_filp_open entry: capture the input name pointer before any lookup or allocation. This is the kernel-side name pointer used for the open.
__d_alloc entry: capture the source pointer used for name copying into a new dentry. This is the copy source.
__d_alloc return: capture the destination pointer for the copied name in the new dentry. This is the copy destination.
do_filp_open return: capture the name pointer referenced by the returned struct file. This is the return pointer we compare against copies and cache hits.
d_lookup entry: capture the hash value, length, and name used as the lookup key. This shows which exact string is hashed for lookup.
d_lookup return: capture the name pointer of a cached dentry on hit. This is the pointer reused on cache hits.
__d_add entry: capture the moment the new dentry name is inserted into the dcache. This is the cache build-up proof.
d_delete entry: capture the moment the name is removed from the dcache hash at unlink time. This is the cache deletion proof.
__dentry_kill entry: capture the moment the dentry is reclaimed by drop_caches. This is the eviction proof.

ASCII diagram: allocation path
```text
user string
    |
    v
do_filp_open entry
    |
    v
__d_alloc entry (copy source)
    |
    v
__d_alloc return (copy destination)
    |
    v
do_filp_open return
```

ASCII diagram: cache hit path
```text
user string
    |
    v
do_filp_open entry
    |
    v
d_lookup return
    |
    v
do_filp_open return
```

ASCII diagram: hash lookup
```text
name string + length
        |
        v
     full_name_hash
        |
        v
   hash value (H)
        |
        v
  d_lookup bucket
```

Results

Run A: matrix_open (root, drop_caches enabled)

Claim A1. Cache eviction happened before first opens.

Evidence:
__dentry_kill entry: 0xffff8bd54073ddb8 | l_e.txt
__dentry_kill entry: 0xffff8bd562809878 | t_e.txt

Claim A2. Cache miss, memcpy, and insert for t_e.txt on first open.

Evidence:
do_filp_open entry pointer = 0xffff8bd543616020
d_lookup entry: hash 1830572521 length 7 name t_e.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd543616025
__d_alloc return pointer = 0xffff8bd540620f38
__d_add entry pointer = 0xffff8bd540620f38
do_filp_open return pointer = 0xffff8bd540620f38

Derivation:
0xffff8bd543616025 - 0xffff8bd543616020 = 0x5 = 5
"/tmp/" length = 5
0xffff8bd540620f38 = __d_alloc return pointer
0xffff8bd540620f38 = __d_add entry pointer
0xffff8bd540620f38 = do_filp_open return pointer

Claim A3. Cache miss and insert for a.txt on loopback ext2.

Evidence:
d_lookup entry: hash 3711754354 length 5 name a.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd54361602c
__d_alloc return pointer = 0xffff8bd5406203f8
__d_add entry pointer = 0xffff8bd5406203f8
do_filp_open return pointer = 0xffff8bd5406203f8

Derivation:
0xffff8bd54361602c - 0xffff8bd543616020 = 0xC = 12
"/mnt/loopfs/" length = 12
0xffff8bd5406203f8 = __d_alloc return pointer
0xffff8bd5406203f8 = __d_add entry pointer
0xffff8bd5406203f8 = do_filp_open return pointer

Claim A4. Cache miss and insert for missing names t_m.txt and l_m.txt.

Evidence:
d_lookup entry: hash 2543581516 length 7 name t_m.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd543616025
__d_alloc return pointer = 0xffff8bd5406200f8
__d_add entry pointer = 0xffff8bd5406200f8

d_lookup entry: hash 1675155717 length 7 name l_m.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd543616020
__d_alloc return pointer = 0xffff8bd5406204b8
__d_add entry pointer = 0xffff8bd5406204b8

Claim A5. Cache hit for l_e.txt and t_e.txt before deletion.

Evidence:
d_lookup entry: hash 399720033 length 7 name l_e.txt
d_lookup return pointer = 0xffff8bd55866ce78

d_lookup entry: hash 1830572521 length 7 name t_e.txt
d_lookup return pointer = 0xffff8bd540620f38

Derivation:
0xffff8bd55866ce78 = do_filp_open return pointer for l_e.txt (first open)
0xffff8bd540620f38 = do_filp_open return pointer for t_e.txt (first open)

Claim A6. Cache deletion via unlink for l_e.txt and t_e.txt.

Evidence:
d_delete entry: 0xffff8bd55866ce78 | l_e.txt
d_delete entry: 0xffff8bd540620f38 | t_e.txt
no d_drop entry lines observed in this run

Claim A7. Cache eviction via drop_caches.

Evidence:
[O] IN: 0xffff8bd543616020 | /proc/sys/vm/drop_caches
[O] OUT: 0xffff8bd6fce05db8 | drop_caches
__dentry_kill entry: 0xffff8bd55866ce78 | l_e.txt
__dentry_kill entry: 0xffff8bd540620f38 | t_e.txt
__dentry_kill entry: 0xffff8bd5406203f8 | a.txt
__dentry_kill entry: 0xffff8bd5406204b8 | l_m.txt
__dentry_kill entry: 0xffff8bd5406200f8 | t_m.txt
matrix_open (82179): drop_caches: 2

Claim A8. Cache rebuild after eviction for t_e.txt.

Evidence:
d_lookup entry: hash 1830572521 length 7 name t_e.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd543616025
__d_alloc return pointer = 0xffff8bd5406206f8
__d_add entry pointer = 0xffff8bd5406206f8
do_filp_open return pointer = 0xffff8bd5406206f8

Derivation:
0xffff8bd5406206f8 != 0xffff8bd540620f38

Claim A9. Hash keys used in Run A.

Evidence:
l_e.txt length 7 hash 399720033
t_e.txt length 7 hash 1830572521
l_m.txt length 7 hash 1675155717
t_m.txt length 7 hash 2543581516
a.txt length 5 hash 3711754354

Run B: minimal_open (target_comm=minimal_open)

Claim B1. Cache miss, memcpy, insert, and later hit for the long filename.

Evidence:
do_filp_open entry pointer = 0xffff8bd54d663020
d_lookup entry: hash 3918709873 length 64 name test_file_very_long_name_to_force_external_allocation_1770404658
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd54d663020
__d_alloc return pointer = 0xffff8bd69f6fb618
__d_add entry pointer = 0xffff8bd69f6fb618
do_filp_open return pointer = 0xffff8bd69f6fb618

cache hit after 5 seconds:
d_lookup entry: hash 3918709873 length 64 name test_file_very_long_name_to_force_external_allocation_1770404658
d_lookup return pointer = 0xffff8bd69f6fb618

Proof map (claims to evidence)

Memcpy of name into dentry storage:
Claim A2, Claim A3, Claim B1

Cache build-up (insert):
Claim A2, Claim A3, Claim A4, Claim B1

Cache hit:
Claim A5, Claim B1

Cache miss:
Claim A2, Claim A3, Claim A4, Claim A8, Claim B1

Cache deletion:
Claim A6

Cache eviction:
Claim A7

Cache rebuild:
Claim A8

Discussion

Every claim above is tied to an explicit probe line and an explicit pointer equality or inequality. The only missing observation is a d_lookup entry line for l_e.txt in the rebuild phase, so rebuild is proven for t_e.txt and not claimed for l_e.txt in that phase. The hash values are shown at d_lookup entry and therefore define the lookup key used in each case.

Conclusion

The data prove that the filename pointer flows into dentry storage via memcpy, that cache inserts happen on misses, that hits return the previously inserted pointer, that deletion removes the dentry on unlink, that eviction removes dentries on drop_caches, and that rebuild occurs after eviction for t_e.txt with a new dentry name pointer.</pre>
  </div>

</body>

</html>