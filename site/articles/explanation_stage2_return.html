<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>window.addEventListener('DOMContentLoaded', () => { if (window.hljs) hljs.highlightAll(); });</script>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    pre code {
      display: block;
      white-space: pre;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">Where does the filename string live when do_filp_open returns?

The filename lives in dentry-&gt;d_name.name. The returned struct file points to this address.

Method: print kernel pointers at 5 locations, compare addresses. If address A equals address B, they point to the same memory. If A - B = 5, the offset is 5 bytes.

Kernel: Linux 6.14.0-37-generic on Ubuntu 24.04
Date: 2026-02-07

minimal_open.c creates test_file_very_long_name_to_force_external_allocation_1770484700
</pre>
<pre><code class="language-c">snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

dmesg output:</pre>
<pre><code>[O] IN: 0xffff8f294c36e020 | test_file_very_long_name_to_force_external_allocation_1770484700
__d_lookup_rcu entry: hash 4193849663 length 64 name test_file_very_long_name_to_force_external_allocation_1770484700
__d_lookup_rcu return: NULL
d_lookup entry: hash 4193849663 length 64 name test_file_very_long_name_to_force_external_allocation_1770484700
d_lookup return: NULL
[A] SRC: 0xffff8f294c36e020
[A] DST: 0xffff8f2bb3de6618
__d_lookup_rcu entry: hash 4193849663 length 64 name test_file_very_long_name_to_force_external_allocation_1770484700
__d_lookup_rcu return: NULL
__d_add entry: 0xffff8f2bb3de6618 | test_file_very_long_name_to_force_external_allocation_1770484700
[O] OUT: 0xffff8f2bb3de6618 | test_file_very_long_name_to_force_external_allocation_1770484700
d_lookup entry: hash 4193849663 length 64 name test_file_very_long_name_to_force_external_allocation_1770484700
d_lookup return: 0xffff8f2bb3de6618 | test_file_very_long_name_to_force_external_allocation_1770484700</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

0xffff8f2bb3de6618 appears at [A] DST, __d_add, [O] OUT, later d_lookup return.
Same numeric address proves: memcpy destination = inserted dentry name = returned file name = later cache hit.
No offset because filename has no directory prefix.

tm_miss.c opens /tmp/t_m.txt twice, file does not exist
</pre>
<pre><code class="language-c">const char *n3 = "/tmp/t_m.txt";
drop_caches_if_root();
sleep(1);
int fd1 = open(n3, O_RDONLY);
printf("tm_miss first open fd=%d\n", fd1);
int fd2 = open(n3, O_RDONLY);
printf("tm_miss second open fd=%d\n", fd2);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

stdout:</pre>
<pre><code>tm_miss first open fd=-1
tm_miss second open fd=-1</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

dmesg output first open:</pre>
<pre><code>[O] IN: 0xffff8f2940f34020 | /tmp/t_m.txt
__d_lookup_rcu entry: hash 3314222277 length 3 name tmp/t_m.txt
__d_lookup_rcu return: 0xffff8f29481d6e78 | tmp
__d_lookup_rcu entry: hash 1429044786 length 7 name t_m.txt
__d_lookup_rcu return: NULL
d_lookup entry: hash 1429044786 length 7 name t_m.txt
d_lookup return: NULL
[A] SRC: 0xffff8f2940f34025
[A] DST: 0xffff8f2bb95c0578
__d_lookup_rcu entry: hash 1429044786 length 7 name t_m.txt
__d_lookup_rcu return: NULL
__d_add entry: 0xffff8f2bb95c0578 | t_m.txt
dput entry: 0xffff8f2bb95c0578 | t_m.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

dmesg output second open:</pre>
<pre><code>[O] IN: 0xffff8f2940f34020 | /tmp/t_m.txt
__d_lookup_rcu entry: hash 3314222277 length 3 name tmp/t_m.txt
__d_lookup_rcu return: 0xffff8f29481d6e78 | tmp
__d_lookup_rcu entry: hash 1429044786 length 7 name t_m.txt
__d_lookup_rcu return: 0xffff8f2bb95c0578 | t_m.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

0xffff8f2940f34025 - 0xffff8f2940f34020 = 0x5 = 5 bytes = strlen("/tmp/")
0xffff8f2bb95c0578 appears at [A] DST, __d_add (first open), __d_lookup_rcu return (second open).
First open: fd=-1, __d_alloc runs, __d_add inserts negative dentry.
Second open: fd=-1, __d_lookup_rcu returns same address, no __d_alloc, no __d_add.
Negative dentry cached: struct exists with d_inode=NULL.

te_miss.c opens /tmp/t_e.txt (file exists)
</pre>
<pre><code class="language-c">const char *n2 = "/tmp/t_e.txt";
close(creat(n2, 0644));
drop_caches_if_root();
sleep(1);
open(n2, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

dmesg output:</pre>
<pre><code>[O] IN: 0xffff8f29465fc020 | /tmp/t_e.txt
__d_lookup_rcu entry: hash 3314222277 length 3 name tmp/t_e.txt
__d_lookup_rcu return: 0xffff8f29481d6e78 | tmp
__d_lookup_rcu entry: hash 1730118631 length 7 name t_e.txt
__d_lookup_rcu return: 0xffff8f294ca81578 | t_e.txt
d_lookup entry: hash 1730118631 length 7 name t_e.txt
d_lookup return: 0xffff8f294ca81578 | t_e.txt
dput entry: 0xffff8f294ca81578 | t_e.txt
[O] OUT: 0xffff8f294ca81578 | t_e.txt
dput entry: 0xffff8f294ca81578 | t_e.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

0xffff8f294ca81578 appears at __d_lookup_rcu return, d_lookup return, [O] OUT.
No [A] SRC or [A] DST lines: __d_alloc did not run.
No __d_add line: no insertion.
Cache hit: d_lookup returned existing dentry, no memcpy, returned file points to cached name.

evict_test.c creates /tmp/evict_test.txt, drops caches, opens again
</pre>
<pre><code class="language-c">const char *name = "/tmp/evict_test.txt";
close(creat(name, 0644));
sleep(1);
if (geteuid() == 0) {
    sync();
    int fd = open("/proc/sys/vm/drop_caches", O_WRONLY);
    if (fd &gt;= 0) {
        write(fd, "2\n", 2);
        close(fd);
    }
}
sleep(1);
int fd = open(name, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

dmesg output first open:</pre>
<pre><code>[O] IN: 0xffff8f294aea3020 | /tmp/evict_test.txt
__d_lookup_rcu entry: hash 3314222277 length 3 name tmp/evict_test.txt
__d_lookup_rcu entry: hash 1728927617 length 14 name evict_test.txt
d_lookup entry: hash 1728927617 length 14 name evict_test.txt
[A] SRC: 0xffff8f294aea3025
[A] DST: 0xffff8f294c931038
__d_lookup_rcu entry: hash 1728927617 length 14 name evict_test.txt
__d_add entry: 0xffff8f294c931038 | evict_test.txt
[O] OUT: 0xffff8f294c931038 | evict_test.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

dmesg output second open (after drop_caches):</pre>
<pre><code>[O] IN: 0xffff8f29465f9020 | /tmp/evict_test.txt
__d_lookup_rcu entry: hash 3314222277 length 3 name tmp/evict_test.txt
__d_lookup_rcu entry: hash 1728927617 length 14 name evict_test.txt
d_lookup entry: hash 1728927617 length 14 name evict_test.txt
[A] SRC: 0xffff8f29465f9025
[A] DST: 0xffff8f2995e79db8
__d_lookup_rcu entry: hash 1728927617 length 14 name evict_test.txt
__d_add entry: 0xffff8f2995e79db8 | evict_test.txt
[O] OUT: 0xffff8f2995e79db8 | evict_test.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

First open: 0xffff8f294aea3025 - 0xffff8f294aea3020 = 0x5 = 5 bytes = strlen("/tmp/")
Second open: 0xffff8f29465f9025 - 0xffff8f29465f9020 = 0x5 = 5 bytes = strlen("/tmp/")

First open: 0xffff8f294c931038 at [A] DST, __d_add, [O] OUT
Second open: 0xffff8f2995e79db8 at [A] DST, __d_add, [O] OUT

0xffff8f2995e79db8 ≠ 0xffff8f294c931038
0xffff8f2995e79db8 - 0xffff8f294c931038 = 0x4b48d80 = 78999936 bytes

Addresses differ. drop_caches evicted dentry. Second open allocated new dentry at different address.
Both opens show __d_alloc (memcpy happened twice).
Basename offset consistent: 5 bytes both times.

Probes:

do_filp_open entry reads regs-&gt;si = struct filename *, prints filename-&gt;name
do_filp_open return reads regs-&gt;ax = struct file *, prints file-&gt;f_path.dentry-&gt;d_name.name
__d_alloc entry reads regs-&gt;si = struct qstr *, prints qstr-&gt;name
__d_alloc return reads regs-&gt;ax = struct dentry *, prints dentry-&gt;d_name.name
d_lookup return reads regs-&gt;ax = struct dentry *, prints dentry-&gt;d_name.name or NULL
__d_lookup_rcu return reads regs-&gt;ax = struct dentry *, prints dentry-&gt;d_name.name or NULL
__d_add entry reads regs-&gt;di = struct dentry *, prints dentry-&gt;d_name.name

Kernel sources:
/usr/src/linux-source-6.8.0/fs/open.c
/usr/src/linux-source-6.8.0/fs/dcache.c
/usr/src/linux-source-6.8.0/include/linux/fs.h
/usr/src/linux-source-6.8.0/include/linux/dcache.h

struct filename { const char *name; const __user char *uptr; int refcnt; struct qstr name_attr; }
struct file { struct path f_path; }
struct path { struct dentry *dentry; }
struct dentry { struct qstr d_name; struct inode *d_inode; }
struct qstr { const unsigned char *name; unsigned int len; unsigned int hash; }

Negative dentry: struct dentry exists with d_inode=NULL.
/usr/src/linux-source-6.8.0/include/linux/dcache.h:</pre>
<pre><code class="language-c">struct inode *d_inode; /* Where the name belongs to - NULL is negative */
static inline bool d_really_is_negative(const struct dentry *dentry) {
    return dentry-&gt;d_inode == NULL;
}</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

memcpy location: /usr/src/linux-source-6.8.0/fs/dcache.c __d_alloc()</pre>
<pre><code class="language-c">memcpy(dname, name-&gt;name, name-&gt;len);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Driver: kernel/drivers/trace_do_filp_open/trace_do_filp_open.c
Kprobes on: do_filp_open, __d_alloc, d_lookup, __d_lookup_rcu, __d_add
Kretprobes on: do_filp_open, __d_alloc, d_lookup, __d_lookup_rcu

Driver filters by process name: target_comm module parameter
Example: insmod trace_do_filp_open.ko target_comm=minimal_open

User programs: kernel/user/stage2/
minimal_open.c: long filename, cache miss
tm_miss.c: negative dentry, missing file opened twice
te_miss.c: cache hit, existing file
evict_test.c: cache invalidation, drop_caches

Build driver:</pre>
<pre><code>cd kernel/drivers/trace_do_filp_open
make clean
make</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Load driver:</pre>
<pre><code>sudo insmod trace_do_filp_open.ko target_comm=minimal_open</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Run test:</pre>
<pre><code>cd kernel/user/stage2
gcc -o minimal_open minimal_open.c
./minimal_open</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Read output:</pre>
<pre><code>sudo dmesg | grep -E "\[O\]|\[A\]|d_lookup|__d_add"</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Unload driver:</pre>
<pre><code>sudo rmmod trace_do_filp_open</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Previous work:

Stage 1: User Space to Syscall Boundary
URL: https://raikrahul.github.io/what-happens-when-open-is-called/stage1.html

User code: open("somefile", O_RDWR) in C source
Preprocessor: expands to __open_2("somefile", O_RDWR) from fcntl.h
Compilation: gcc generates call to open@plt
Linking: ld creates PLT stub that jumps to GOT entry
Runtime: dynamic linker fills GOT with libc address
Libc: glibc transforms open() to openat(AT_FDCWD, "somefile", O_RDWR, 0)
Syscall: openat() uses syscall instruction with RAX=257 (openat syscall number)
Registers: RDI=-100 (AT_FDCWD), RSI=0x7ffe... (filename pointer), RDX=0x2 (O_RDWR), R10=0 (mode)

objdump -d minimal_open: showed call to open@plt
readelf -r minimal_open: showed R_X86_64_JUMP_SLOT relocation for open
gdb: set breakpoint at open, stepped through PLT/GOT, captured register values
strace: showed openat(AT_FDCWD, "somefile", O_RDWR) = 3

PLT stub: 0x401030
GOT entry: 0x404018
Libc open: 0x7ffff7d1b150
Filename pointer in RSI: 0x7fffffffe3a0

objdump showed "jmp *0x2fe2(%rip)" which calculates to GOT address 0x404018.
readelf showed this GOT entry holds the relocation for open.
gdb showed after dynamic linking, GOT[0x404018] = 0x7ffff7d1b150 (libc address).
PLT → GOT → libc chain verified.

Stage 2 Entry: Kernel Space - Tracing getname()
URL: https://raikrahul.github.io/what-happens-when-open-is-called/stage2.html

Kernel entry: openat syscall lands in do_sys_openat2 (fs/open.c:1388)
First kernel function: getname(filename) at line 1398
getname() copies user string to kernel memory
getname() returns struct filename * with kernel copy

Kernel module: kernel/drivers/arg2_filename/trace_filename.c
Kprobe on do_sys_openat2 entry: captured RDI register = user pointer 0x7ffe...
Kretprobe on getname return: captured RAX register = struct filename * at 0xffff...
Dereferenced struct filename-&gt;name: printed kernel copy address 0xffff...
Compared addresses: user pointer (0x7ffe...) != kernel copy (0xffff...)

User pointer (RDI at do_sys_openat2 entry): 0x7fffffffe3a0
struct filename * (RAX at getname return): 0xffff8bd546396000
Kernel copy (struct filename-&gt;name): 0xffff8bd546396020

kprobe printed user pointer 0x7ffe... from RDI.
kretprobe printed struct filename * 0xffff... from RAX.
Dereferenced filename-&gt;name at offset +0 and printed 0xffff...020.
Addresses differ by 0x20 bytes (struct filename header).
User pointer starts with 0x7ffe (user space range).
Kernel pointer starts with 0xffff (kernel space range).
getname() copied the string from user space to kernel space.

Stage 2 Return: This Document
URL: https://raikrahul.github.io/what-happens-when-open-is-called/articles/explanation_stage2_return.html

do_filp_open receives struct filename * from getname
do_filp_open returns struct file * pointing to dentry name
__d_alloc copies filename from struct qstr to dentry
d_lookup searches cache before __d_alloc
Returned file struct points to dentry-&gt;d_name.name
Cache hit reuses existing dentry name (no copy)
Cache miss allocates new dentry and copies name
Eviction (drop_caches) frees dentry, next open allocates new one
Negative dentry caches "file does not exist" result

5 kprobes print addresses at exact transitions
Pointer equality proves same memory (A == B)
Pointer subtraction proves basename offset (A - B = 5 = strlen("/tmp/"))
Address change after drop_caches proves new allocation
Same address on second open of missing file proves negative dentry cache

Complete chain:
User space open("file") → libc openat(AT_FDCWD, "file", flags) → syscall → kernel do_sys_openat2 → getname copies to kernel → do_filp_open → __d_alloc copies to dentry → return struct file pointing to dentry name.

Every step verified with printed addresses from actual runs.</pre>
  </div>

</body>

</html>
