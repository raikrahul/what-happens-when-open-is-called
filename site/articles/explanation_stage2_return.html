<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return</title>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">Abstract

We measure the filename string as it passes through do_filp_open and the dentry cache. We record input pointers, copy source and destination, return pointers, cache hits, hash values, explicit cache insert events via __d_add, and cache removal events via d_delete and __dentry_kill. We also add a loopback filesystem case with a short name to show a distinct filesystem path and use drop_caches to force eviction. The results show that do_filp_open returns a pointer to the dentry name. On cache miss, __d_alloc copies the name and the return pointer equals the copy destination, and __d_add shows the insert into the dcache. On cache hit, d_lookup returns the same pointer as the prior return. d_delete and __dentry_kill show deletion and eviction. Hash values and lengths printed at d_lookup entry prove the lookup keys used for each name.

Prior Work

Stage 1: https://raikrahul.github.io/what-happens-when-open-is-called/stage1.html
Stage 2 Entry: https://raikrahul.github.io/what-happens-when-open-is-called/stage2.html
Worksheet: https://raikrahul.github.io/what-happens-when-open-is-called/articles/worksheet_stage2_return.html

Introduction

The goal of this stage is concrete: identify where the filename string ends up at return time and prove it with data. The measurement must include both allocation and cache paths and must show the hash values used for lookup. The test programs are designed to produce both paths in one run, and a loopback filesystem test adds a distinct filesystem path and a short name.

Methods

User-space programs:

minimal_open.c
```c
snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);
sleep(5);
```

matrix_open.c
```c
close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
sleep(2);
close_all();
unlink("l_e.txt");
unlink("/tmp/t_e.txt");
close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
``` 

Per-line purpose

close(creat("l_e.txt", 0644)); creates a local file so the first open can hit a real inode in the current directory.
close(creat("/tmp/t_e.txt", 0644)); creates a file under /tmp so the path has a prefix and produces a basename shift in the copy source pointer.
drop_caches_if_root(); evicts dentry cache entries so the next opens show cache misses and inserts.
sleep(1); allows eviction to complete before the first opens.
open("l_e.txt", O_RDONLY); first open of an existing local file, intended to show allocation or cache miss behavior.
open("/tmp/t_e.txt", O_RDONLY); first open of an existing /tmp file, intended to show basename copy and allocation.
open("/tmp/t_m.txt", O_RDONLY); open of a missing /tmp file, intended to show an error path with no returned file pointer.
open("l_e.txt", O_RDONLY); second open of the same local file, intended to show a cache hit and pointer reuse.
open("l_m.txt", O_RDONLY); open of a missing local file, intended to show a second error path.
open("/mnt/loopfs/a.txt", O_RDONLY); open of a file on a loopback ext2 filesystem, intended to show the same flow on a different filesystem and a short name.
open("l_e.txt", O_RDONLY); third open of the local file, intended to show repeated cache hit stability.
sleep(2); allows cache hit probes to run before deletion.
close_all(); releases file descriptors so dentries can be deleted or evicted.
unlink("l_e.txt"); deletes the local file name, intended to show d_delete for that dentry.
unlink("/tmp/t_e.txt"); deletes the /tmp file name, intended to show d_delete for that dentry.
close(creat("l_e.txt", 0644)); recreates the local file name for rebuild tests.
close(creat("/tmp/t_e.txt", 0644)); recreates the /tmp file name for rebuild tests.
open("l_e.txt", O_RDONLY); reopen after deletion to observe reuse or rebuild.
open("/tmp/t_e.txt", O_RDONLY); reopen after deletion to observe reuse or rebuild.
drop_caches_if_root(); forces eviction to prove rebuild after eviction.
sleep(1); allows eviction to complete.
open("l_e.txt", O_RDONLY); reopen after eviction to observe rebuild.
open("/tmp/t_e.txt", O_RDONLY); reopen after eviction to observe rebuild.

Loopback filesystem test:

- 64M loopback file formatted as ext2
- mounted at /mnt/loopfs
- a.txt created, sync, unmount, remount

Symbol availability proof (from this machine)

Kernel headers and sources:

uname -r: 6.14.0-37-generic
/usr/src contains linux-headers-6.14.0-37-generic
/usr/src contains linux-source-6.8.0

kptr_restrict: 1
perf_event_paranoid: 4

Symbols in /proc/kallsyms:

__d_add: ffffffff89beaaa0 (local symbol, type t)
d_add: ffffffff89beaca0 (global symbol, type T)
d_rehash: ffffffff89bea3e0 (global symbol, type T)
d_add_ci: ffffffff89becf20 (global symbol, type T)
full_name_hash: ffffffff89bd5010 (global symbol, type T)

Why __d_add is not in available_filter_functions:
available_filter_functions is the ftrace function list, not a full symbol list. It only includes functions that ftrace exposes (non-inlined, traceable, and globally visible). __d_add is present as a local symbol in kallsyms, so kprobe can attach to it, but ftrace does not list it.

Probe map and observed fields:

- do_filp_open entry: input filename pointer
- __d_alloc entry: copy source pointer
- __d_alloc return: copy destination pointer
- do_filp_open return: returned struct file name pointer
- d_lookup entry: hash value, length, and name string
- d_lookup return: cache hit name pointer
- __d_lookup entry: hash value, length, and name string at internal lookup
- __d_lookup_rcu entry: hash value, length, and name string in RCU path
- __d_add entry: dentry name pointer at insert into dcache
- d_delete entry: dentry name pointer at unlink removal
- __dentry_kill entry: dentry name pointer at eviction via drop_caches

Memcpy proof (kernel source)

File: /usr/src/linux-source-6.8.0/fs/dcache.c:1660
memcpy(dname, name-&gt;name, name-&gt;len);

Per-probe purpose

do_filp_open entry: capture the input name pointer before any lookup or allocation. This is the kernel-side name pointer used for the open.
__d_alloc entry: capture the source pointer used for name copying into a new dentry. This is the copy source.
__d_alloc return: capture the destination pointer for the copied name in the new dentry. This is the copy destination.
do_filp_open return: capture the name pointer referenced by the returned struct file. This is the return pointer we compare against copies and cache hits.
d_lookup entry: capture the hash value, length, and name used as the lookup key. This shows which exact string is hashed for lookup.
d_lookup return: capture the name pointer of a cached dentry on hit. This is the pointer reused on cache hits.
__d_lookup entry: capture the same hash, length, and name on the internal lookup path. This is used when the lookup path bypasses the external wrapper.
__d_lookup_rcu entry: capture the hash, length, and name on the RCU fast path lookup.
__d_add entry: capture the moment the new dentry name is inserted into the dcache. This is the cache build-up proof.
d_delete entry: capture the moment the name is removed from the dcache hash at unlink time. This is the cache deletion proof.
__dentry_kill entry: capture the moment the dentry is reclaimed by drop_caches. This is the eviction proof.

ASCII diagram: allocation path
```text
user string
    |
    v
do_filp_open entry
    |
    v
__d_alloc entry (copy source)
    |
    v
__d_alloc return (copy destination)
    |
    v
do_filp_open return
```

ASCII diagram: cache hit path
```text
user string
    |
    v
do_filp_open entry
    |
    v
d_lookup return
    |
    v
do_filp_open return
```

ASCII diagram: hash lookup
```text
name string + length
        |
        v
     full_name_hash
        |
        v
   hash value (H)
        |
        v
  d_lookup bucket
```

Results

Run A: matrix_open (root, drop_caches enabled)

Research Narrative (Run A)

This section preserves every pointer, address, and line from the trace while adding the logical structure expected of a research textbook. Each claim is followed by direct evidence and a derivation that uses only the data printed above.

Claim A1. Cache miss, memcpy, and insert for t_e.txt.

User-space code that triggers this evidence (matrix_open.c):
```c
char n2[] = "/tmp/t_e.txt";
close(creat(n2, 0644));
drop_caches_if_root();
sleep(1);

f[1] = open(n2, O_RDONLY);
```

Kernel evidence:
do_filp_open entry pointer = 0xffff8bd5423ed020 | /tmp/t_e.txt
d_lookup entry: hash 1830572521 length 7 name t_e.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd5423ed025
__d_alloc return pointer = 0xffff8bd54e246db8
__d_add entry: 0xffff8bd54e246db8 | t_e.txt
do_filp_open return pointer = 0xffff8bd54e246db8 | t_e.txt

Pointer meanings (t_e.txt):
- do_filp_open entry pointer 0xffff8bd5423ed020 points to the kernel-side string "/tmp/t_e.txt" used for this open call.
- d_lookup entry uses the basename "t_e.txt" (length 7) and hash 1830572521 as the lookup key for this path.
- d_lookup return: NULL means no cached dentry matched that key.
- __d_alloc entry pointer 0xffff8bd5423ed025 points to the basename start inside the same string (after "/tmp/").
- __d_alloc return pointer 0xffff8bd54e246db8 points to newly allocated dentry name storage.
- __d_add entry pointer 0xffff8bd54e246db8 shows that same storage inserted into the dcache hash.
- do_filp_open return pointer 0xffff8bd54e246db8 shows the returned file points at that dentry name storage.

Derivation (user-space trigger and why):
User-space code:
```c
char n2[] = "/tmp/t_e.txt";
close(creat(n2, 0644));
drop_caches_if_root();
sleep(1);

f[1] = open(n2, O_RDONLY);
```
Why this creates the pointer subtraction:
- The open string is "/tmp/t_e.txt".
- The basename starts after the 5-byte prefix "/tmp/".
- The basename pointer equals the original pointer plus 5.

Derivation (data):
0xffff8bd5423ed025 - 0xffff8bd5423ed020 = 0x5 = 5
"/tmp/" length = 5
0xffff8bd54e246db8 = __d_alloc return pointer
0xffff8bd54e246db8 = __d_add entry pointer
0xffff8bd54e246db8 = do_filp_open return pointer

Claim A2. Cache miss and insert for missing t_m.txt.

User-space code that triggers this evidence (matrix_open.c):
```c
char n3[] = "/tmp/t_m.txt";

f[2] = open(n3, O_RDONLY);
```

Kernel evidence:
do_filp_open entry pointer = 0xffff8bd5423ed020 | /tmp/t_m.txt
d_lookup entry: hash 2543581516 length 7 name t_m.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd5423ed025
__d_alloc return pointer = 0xffff8bd5560a0ab8
__d_add entry: 0xffff8bd5560a0ab8 | t_m.txt

Pointer meanings (t_m.txt):
- do_filp_open entry pointer 0xffff8bd5423ed020 points to "/tmp/t_m.txt" in kernel memory for this open.
- d_lookup entry hash 2543581516 and length 7 use basename "t_m.txt" as the key.
- d_lookup return: NULL shows no cached dentry matched.
- __d_alloc entry pointer 0xffff8bd5423ed025 points to basename start after "/tmp/".
- __d_alloc return pointer 0xffff8bd5560a0ab8 is the newly allocated dentry name storage.
- __d_add entry pointer 0xffff8bd5560a0ab8 inserts that name storage into the dcache as a negative entry.

Claim A3. Cache miss and insert for missing l_m.txt.

User-space code that triggers this evidence (matrix_open.c):
```c
char n4[] = "l_m.txt";

f[4] = open(n4, O_RDONLY);
```

Kernel evidence:
do_filp_open entry pointer = 0xffff8bd5423ed020 | l_m.txt
d_lookup entry: hash 1675155717 length 7 name l_m.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd5423ed020
__d_alloc return pointer = 0xffff8bd5560a0c38
__d_add entry: 0xffff8bd5560a0c38 | l_m.txt

Pointer meanings (l_m.txt):
- do_filp_open entry pointer 0xffff8bd5423ed020 points to "l_m.txt" for this open.
- d_lookup entry hash 1675155717 and length 7 use basename "l_m.txt" as the key.
- d_lookup return: NULL shows no cached dentry matched.
- __d_alloc entry pointer 0xffff8bd5423ed020 equals the string start (no prefix).
- __d_alloc return pointer 0xffff8bd5560a0c38 is the newly allocated dentry name storage.
- __d_add entry pointer 0xffff8bd5560a0c38 inserts that name storage into the dcache as a negative entry.

Claim A4. Cache miss, memcpy, and insert for a.txt on loopback ext2.

User-space code that triggers this evidence (matrix_open.c):
```c
char n5[] = "/mnt/loopfs/a.txt";

f[5] = open(n5, O_RDONLY);
```

Kernel evidence:
do_filp_open entry pointer = 0xffff8bd5423ed020 | /mnt/loopfs/a.txt
d_lookup entry: hash 3711754354 length 5 name a.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd5423ed02c
__d_alloc return pointer = 0xffff8bd5560a09f8
__d_add entry: 0xffff8bd5560a09f8 | a.txt
do_filp_open return pointer = 0xffff8bd5560a09f8 | a.txt

Pointer meanings (a.txt):
- do_filp_open entry pointer 0xffff8bd5423ed020 points to "/mnt/loopfs/a.txt" in kernel memory for this open.
- d_lookup entry hash 3711754354 and length 5 use basename "a.txt" as the key.
- d_lookup return: NULL shows no cached dentry matched.
- __d_alloc entry pointer 0xffff8bd5423ed02c points to basename start after "/mnt/loopfs/".
- __d_alloc return pointer 0xffff8bd5560a09f8 is the newly allocated dentry name storage.
- __d_add entry pointer 0xffff8bd5560a09f8 inserts that name storage into the dcache.
- do_filp_open return pointer 0xffff8bd5560a09f8 shows the returned file points at that dentry name storage.

Derivation:
0xffff8bd5423ed02c - 0xffff8bd5423ed020 = 0xC = 12
"/mnt/loopfs/" length = 12
0xffff8bd5560a09f8 = __d_alloc return pointer
0xffff8bd5560a09f8 = __d_add entry pointer
0xffff8bd5560a09f8 = do_filp_open return pointer

Claim A5. Cache hit for l_e.txt and t_e.txt before deletion.

User-space code that triggers this evidence (matrix_open.c):
```c
char n1[] = "l_e.txt";
char n2[] = "/tmp/t_e.txt";

// first opens happen earlier
f[3] = open(n1, O_RDONLY);

// later opens hit cache
f[0] = open(n1, O_RDONLY);
f[1] = open(n2, O_RDONLY);
```

Kernel evidence:
d_lookup entry: hash 399720033 length 7 name l_e.txt
d_lookup return: 0xffff8bd54e8d9878 | l_e.txt

Pointer meanings (cache hits):
- d_lookup return pointer 0xffff8bd54e8d9878 for l_e.txt matches the earlier return pointer for l_e.txt, so the cached dentry is reused.
- d_lookup return pointer 0xffff8bd54e246db8 for t_e.txt matches the earlier return pointer for t_e.txt, so the cached dentry is reused.

d_lookup entry: hash 1830572521 length 7 name t_e.txt
d_lookup return: 0xffff8bd54e246db8 | t_e.txt

Claim A6. Cache deletion via unlink.

User-space code that triggers this evidence (matrix_open.c):
```c
unlink("l_e.txt");
unlink("/tmp/t_e.txt");
```

Kernel evidence:
d_delete entry: 0xffff8bd54e8d9878 | l_e.txt
d_delete entry: 0xffff8bd54e246db8 | t_e.txt
no d_drop entry lines observed in this run

Claim A7. Cache eviction via drop_caches.

User-space code that triggers this evidence (matrix_open.c):
```c
drop_caches_if_root();
// writes "2\n" to /proc/sys/vm/drop_caches
```

Kernel evidence:
do_filp_open entry pointer = 0xffff8bd54d6aa020 | /proc/sys/vm/drop_caches
do_filp_open return pointer = 0xffff8bd6fce05db8 | drop_caches
__dentry_kill entry: 0xffff8bd54e8d9878 | l_e.txt
__dentry_kill entry: 0xffff8bd54e246db8 | t_e.txt
matrix_open (86584): drop_caches: 2

Claim A8. Cache rebuild after eviction for t_e.txt.

User-space code that triggers this evidence (matrix_open.c):
```c
drop_caches_if_root();
sleep(1);

// reopen after eviction
f[0] = open("l_e.txt", O_RDONLY);
f[1] = open("/tmp/t_e.txt", O_RDONLY);
```

Kernel evidence:
d_lookup entry: hash 1830572521 length 7 name t_e.txt
__d_alloc entry pointer = 0xffff8bd54d6aa025
__d_alloc return pointer = 0xffff8bd572e4aab8
__d_add entry: 0xffff8bd572e4aab8 | t_e.txt
do_filp_open return pointer = 0xffff8bd572e4aab8 | t_e.txt

Derivation:
0xffff8bd572e4aab8 != 0xffff8bd54e246db8

Claim A9. Post-eviction lookup observed for l_e.txt.

User-space code that triggers this evidence (matrix_open.c):
```c
drop_caches_if_root();
sleep(1);

// reopen after eviction
f[0] = open("l_e.txt", O_RDONLY);
```

Kernel evidence:
do_filp_open entry pointer = 0xffff8bd54d6aa020 | l_e.txt
__d_lookup_rcu entry: hash 399720033 length 7 name l_e.txt
do_filp_open return pointer = 0xffff8bd5406080f8 | l_e.txt

Derivation:
0xffff8bd5406080f8 != 0xffff8bd54e8d9878

Claim A10. Hash keys used in Run A.

User-space code that triggers this evidence (matrix_open.c):
```c
// these names are opened in this run:
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);
```

Kernel evidence:
l_e.txt length 7 hash 399720033
t_e.txt length 7 hash 1830572521
l_m.txt length 7 hash 1675155717
t_m.txt length 7 hash 2543581516
a.txt length 5 hash 3711754354

Run B: minimal_open (target_comm=minimal_open)

Claim B1. Cache miss, memcpy, insert, and later hit for the long filename.

Evidence:
do_filp_open entry pointer = 0xffff8bd54d663020
d_lookup entry: hash 3918709873 length 64 name test_file_very_long_name_to_force_external_allocation_1770404658
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd54d663020
__d_alloc return pointer = 0xffff8bd69f6fb618
__d_add entry pointer = 0xffff8bd69f6fb618
do_filp_open return pointer = 0xffff8bd69f6fb618

cache hit after 5 seconds:
d_lookup entry: hash 3918709873 length 64 name test_file_very_long_name_to_force_external_allocation_1770404658
d_lookup return pointer = 0xffff8bd69f6fb618

Proof map (claims to evidence)

Memcpy of name into dentry storage:
Claim A1, Claim A4, Claim B1

Cache build-up (insert):
Claim A1, Claim A2, Claim A3, Claim A4, Claim A8, Claim B1

Cache hit:
Claim A5, Claim B1

Cache miss:
Claim A1, Claim A2, Claim A3, Claim A4, Claim B1

Cache deletion:
Claim A6

Cache eviction:
Claim A7

Cache rebuild:
Claim A8

Discussion

Every claim above is tied to an explicit probe line and an explicit pointer equality or inequality. The RCU lookup path is recorded via __d_lookup_rcu for l_e.txt after eviction. Rebuild with explicit __d_add is proven for t_e.txt; l_e.txt is only shown with post-eviction lookup and a new return pointer. The hash values are shown at d_lookup entry (and also at __d_lookup/__d_lookup_rcu) and therefore define the lookup key used in each case.

Conclusion

The data prove that the filename pointer flows into dentry storage via memcpy, that cache inserts happen on misses, that hits return the previously inserted pointer, that deletion removes the dentry on unlink, that eviction removes dentries on drop_caches, and that rebuild occurs after eviction for t_e.txt with a new dentry name pointer. For l_e.txt after eviction, the lookup is observed on the RCU path and returns a new pointer, but an explicit insert line is not observed in this run.

Full Proofs (No Data Removed)

Proof 1. memcpy of filename into dentry storage.

Evidence (t_e.txt):
__d_alloc entry pointer = 0xffff8bd5423ed025
__d_alloc return pointer = 0xffff8bd54e246db8
__d_add entry: 0xffff8bd54e246db8 | t_e.txt
do_filp_open return pointer = 0xffff8bd54e246db8 | t_e.txt

Derivation:
0xffff8bd54e246db8 = __d_alloc return pointer
0xffff8bd54e246db8 = __d_add entry pointer
0xffff8bd54e246db8 = do_filp_open return pointer

Evidence (a.txt):
__d_alloc entry pointer = 0xffff8bd5423ed02c
__d_alloc return pointer = 0xffff8bd5560a09f8
__d_add entry: 0xffff8bd5560a09f8 | a.txt
do_filp_open return pointer = 0xffff8bd5560a09f8 | a.txt

Derivation:
0xffff8bd5560a09f8 = __d_alloc return pointer
0xffff8bd5560a09f8 = __d_add entry pointer
0xffff8bd5560a09f8 = do_filp_open return pointer

Evidence (long filename):
__d_alloc entry pointer = 0xffff8bd54d663020
__d_alloc return pointer = 0xffff8bd69f6fb618
__d_add entry: 0xffff8bd69f6fb618 | test_file_very_long_name_to_force_external_allocation_1770404658
do_filp_open return pointer = 0xffff8bd69f6fb618 | test_file_very_long_name_to_force_external_allocation_1770404658

Derivation:
0xffff8bd69f6fb618 = __d_alloc return pointer
0xffff8bd69f6fb618 = __d_add entry pointer
0xffff8bd69f6fb618 = do_filp_open return pointer

Proof 2. Cache build-up (insert) on miss.

Evidence:
d_lookup return: NULL
__d_add entry: 0xffff8bd54e246db8 | t_e.txt

d_lookup return: NULL
__d_add entry: 0xffff8bd5560a0ab8 | t_m.txt

d_lookup return: NULL
__d_add entry: 0xffff8bd5560a0c38 | l_m.txt

d_lookup return: NULL
__d_add entry: 0xffff8bd5560a09f8 | a.txt

d_lookup return: NULL
__d_add entry: 0xffff8bd69f6fb618 | test_file_very_long_name_to_force_external_allocation_1770404658

Proof 3. Cache miss.

Evidence:
d_lookup return: NULL (t_e.txt)
d_lookup return: NULL (t_m.txt)
d_lookup return: NULL (l_m.txt)
d_lookup return: NULL (a.txt)
d_lookup return: NULL (long filename)

Proof 4. Cache hit.

Evidence:
d_lookup entry: hash 399720033 length 7 name l_e.txt
d_lookup return: 0xffff8bd54e8d9878 | l_e.txt

d_lookup entry: hash 1830572521 length 7 name t_e.txt
d_lookup return: 0xffff8bd54e246db8 | t_e.txt

d_lookup entry: hash 3918709873 length 64 name test_file_very_long_name_to_force_external_allocation_1770404658
d_lookup return pointer = 0xffff8bd69f6fb618

Proof 5. Cache delete.

Evidence:
d_delete entry: 0xffff8bd54e8d9878 | l_e.txt
d_delete entry: 0xffff8bd54e246db8 | t_e.txt

Proof 6. Long filename behavior.

Evidence:
d_lookup entry: hash 3918709873 length 64 name test_file_very_long_name_to_force_external_allocation_1770404658
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd54d663020
__d_alloc return pointer = 0xffff8bd69f6fb618
__d_add entry: 0xffff8bd69f6fb618 | test_file_very_long_name_to_force_external_allocation_1770404658
do_filp_open return pointer = 0xffff8bd69f6fb618 | test_file_very_long_name_to_force_external_allocation_1770404658

Proof 7. Short filename behavior.

Evidence:
d_lookup entry: hash 3711754354 length 5 name a.txt
d_lookup return: NULL
__d_alloc entry pointer = 0xffff8bd5423ed02c
__d_alloc return pointer = 0xffff8bd5560a09f8
__d_add entry: 0xffff8bd5560a09f8 | a.txt
do_filp_open return pointer = 0xffff8bd5560a09f8 | a.txt

Derivation:
0xffff8bd5423ed02c - 0xffff8bd5423ed020 = 0xC = 12
"/mnt/loopfs/" length = 12

What We Failed To Observe And Why

1. We did not observe a __d_add line for l_e.txt in the post-eviction rebuild phase. The post-eviction lookup is visible on the RCU path and returns a new pointer, but an explicit insert line for l_e.txt was not printed in this run. This is why Claim A9 is phrased as a post-eviction lookup, not an explicit insert for l_e.txt.
2. We did not observe any d_drop entry lines for these names. The d_delete lines are present, so deletion is proven, but d_drop did not fire for these paths in this run.</pre>
  </div>

</body>

</html>