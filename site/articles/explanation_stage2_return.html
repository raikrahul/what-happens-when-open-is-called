<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Stage 2 Return</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
  <script>window.addEventListener('DOMContentLoaded', () => { if (window.hljs) hljs.highlightAll(); });</script>
  <style>
    body {
      background: #fff;
      color: #000;
      font-family: monospace;
      font-size: 13px;
      line-height: 1.2;
      padding: 0 5px;
      margin: 0;
    }

    pre {
      margin: 0.5em 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    pre code {
      display: block;
      white-space: pre;
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      margin: 0.5em 0 0.2em 0;
      font-size: 1em;
      font-weight: bold;
      text-transform: uppercase;
    }

    p,
    ul,
    ol {
      margin: 0.5em 0;
    }

    hr {
      margin: 0.5em 0;
      border: none;
      border-bottom: 1px dashed #000;
    }

    .blank {
      display: inline-block;
      min-width: 150px;
      border-bottom: 1px solid #000;
      color: #000;
    }

    @media print {

      button,
      div[style*="text-align: right"] {
        display: none !important;
      }

      body {
        padding: 0;
      }
    }
  </style>
</head>

<body>
  <div style="text-align: right; font-size: 10px; padding: 2px;">
    <span><a href="../index.html" style="color: #666; text-decoration: none;">[HOME]</a></span>
    <button onclick="window.print()" style="font-size: 10px; cursor: pointer;">Print</button>
  </div>
  <div class="content">
    <pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">Disclaimer: addresses and hash values are from one run; your run will differ.

This stage traces one thing and nothing else: the user‑space filename string as it turns into a
kernel pointer, gets copied, hashed, cached, deleted, and reused on return. No VMs, no heavy
tracers, no filters—only dmesg plus kprobes/kretprobes. If it is not tied to a printed pointer,
hash, or a kernel source line, it is not stated.

Prior Work

Stage 1: https://raikrahul.github.io/what-happens-when-open-is-called/stage1.html
Stage 2 Entry: https://raikrahul.github.io/what-happens-when-open-is-called/stage2.html
Worksheet: https://raikrahul.github.io/what-happens-when-open-is-called/articles/worksheet_stage2_return.html

Programs

minimal_open.c</pre>
<pre><code class="language-c">snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);
sleep(5);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

matrix_open.c</pre>
<pre><code class="language-c">close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);
open("l_e.txt", O_RDONLY);
sleep(2);
close_all();
unlink("l_e.txt");
unlink("/tmp/t_e.txt");
close(creat("l_e.txt", 0644));
close(creat("/tmp/t_e.txt", 0644));
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
drop_caches_if_root();
sleep(1);
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Per-line purpose is in the inline `//` comments in `kernel/user/stage2/matrix_open.c`. Each open,
unlink, and drop_caches call is annotated next to the code line, so no duplicate listing appears
here.

Loopback filesystem test:
- 64M loopback file formatted as ext2
- mounted at /mnt/loopfs
- a.txt created, sync, unmount, remount

Probe map</pre>
<pre><code class="language-text">do_filp_open entry -&gt; input filename pointer + string -&gt; establishes kernel-side name before lookup -&gt; driver open entry probe
__d_alloc entry -&gt; copy source pointer (qstr-&gt;name) -&gt; driver alloc entry probe
__d_alloc return -&gt; copy destination pointer (dentry-&gt;d_name.name) -&gt; driver alloc return probe
do_filp_open return -&gt; returned file name pointer -&gt; ties file to dentry name storage -&gt; driver open return probe
d_lookup entry -&gt; hash, length, name -&gt; defines lookup key used for cache search -&gt; driver lookup entry probe
d_lookup return -&gt; dentry name pointer + string or NULL -&gt; driver lookup return probe
__d_lookup entry -&gt; hash, length, name -&gt; internal lookup path key -&gt; driver __d_lookup probe
__d_lookup_rcu entry -&gt; hash, length, name -&gt; RCU fast-path lookup key -&gt; driver __d_lookup_rcu probe
full_name_hash return -&gt; hash, length, salt, name -&gt; records hash computation (if observed) -&gt; driver hash ret probe
__d_add entry -&gt; dentry name pointer + string -&gt; driver __d_add probe
d_delete entry -&gt; dentry name pointer + string -&gt; driver d_delete probe
__dentry_kill entry -&gt; dentry name pointer + string -&gt; driver __dentry_kill probe</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Memcpy proof anchor
`/usr/src/linux-source-6.8.0/fs/dcache.c:1660` memcpy(dname, name-&gt;name, name-&gt;len);

Run A: matrix_open (root, drop_caches enabled)

l_m.txt miss, insert.</pre>
<pre><code class="language-c">char n4[] = "l_m.txt";

f[4] = open(n4, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
open_entry: do_filp_open entry pointer = 0xffff8bd546392020 | l_m.txt
d_lookup entry from lookup_entry: hash 2166850383 length 7 name l_m.txt
d_lookup return from lookup_ret: NULL
alloc_entry: __d_alloc entry pointer = 0xffff8bd546392020
alloc_ret: __d_alloc return pointer = 0xffff8bd728c76938
__d_add entry from d_add_entry: 0xffff8bd728c76938 | l_m.txt

The entry pointer 0xffff8bd546392020 is f-&gt;name from do_filp_open entry (trace_do_filp_open.c: open_entry). Its type is const char * inside struct filename (include/linux/fs.h). The printed string is l_m.txt, so the kernel pathname buffer begins at that address and the filename part begins at the same address because there is no prefix. The lookup key is l_m.txt with length 7 and hash 2166850383, and d_lookup reads qstr-&gt;len and qstr-&gt;name (include/linux/dcache.h, fs/dcache.c), so the lookup uses 7 bytes. The lookup returns NULL, so there is no cached entry for that key. The allocation source pointer is 0xffff8bd546392020, which equals the pathname buffer start, so qstr-&gt;name points to the filename part in that buffer. The allocation return pointer is 0xffff8bd728c76938, which is dentry-&gt;d_name.name (struct dentry in include/linux/dcache.h) returned by __d_alloc. The insert line uses 0xffff8bd728c76938, so that same dentry name pointer is inserted into the dcache hash for l_m.txt.

t_e.txt miss, memcpy, insert.</pre>
<pre><code class="language-c">char n2[] = "/tmp/t_e.txt";
close(creat(n2, 0644));
drop_caches_if_root();
sleep(1);

f[1] = open(n2, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
`|` separates pointer value (left) and the string read from that pointer (right).
open_entry: do_filp_open entry pointer = 0xffff8bd546392020 | /tmp/t_e.txt
d_lookup entry from lookup_entry: hash 1830572521 length 7 name t_e.txt
d_lookup return from lookup_ret: NULL
alloc_entry: __d_alloc entry pointer = 0xffff8bd546392025
alloc_ret: __d_alloc return pointer = 0xffff8bd728c76338
__d_add entry from d_add_entry: 0xffff8bd728c76338 | t_e.txt
open_ret: do_filp_open return pointer = 0xffff8bd728c76338 | t_e.txt
Map
"/tmp/t_e.txt" @ 0xffff8bd546392020 -&gt; d_lookup (t_e.txt, 7, 1830572521) -&gt; NULL -&gt; __d_alloc entry 0xffff8bd546392025 -&gt; __d_alloc return 0xffff8bd728c76338 -&gt; __d_add 0xffff8bd728c76338 -&gt; do_filp_open return 0xffff8bd728c76338.

Derivation.
0xffff8bd546392025 - 0xffff8bd546392020 = 0x5 = 5
"/tmp/" length = 5
0xffff8bd728c76338 = __d_alloc return pointer = __d_add entry pointer = do_filp_open return pointer

In the probe output lines, the part after `|` is the string read from that pointer and printed by the driver.

Path reasoning (t_e.txt).
The entry line prints f-&gt;name from the do_filp_open argument (trace_do_filp_open.c: open_entry), so 0xffff8bd546392020 is the kernel-resident pathname buffer for this call.
d_lookup uses qstr-&gt;name and qstr-&gt;len (`/usr/src/linux-source-6.8.0/fs/dcache.c`, d_lookup/__d_lookup). The entry prints length 7 name t_e.txt; /tmp/t_e.txt is 12 bytes, so the lookup key is the 7‑byte basename, not the full path.
d_lookup return: NULL, so allocation follows.
__d_alloc entry pointer = 0xffff8bd546392025. This equals 0xffff8bd546392020 + 5; 5 is the length of "/tmp/". So qstr-&gt;name for __d_alloc points at the filename part after the "/tmp/" prefix in the same kernel buffer.
__d_alloc return pointer = 0xffff8bd728c76338, a different address than 0xffff8bd546392020.
__d_add entry shows 0xffff8bd728c76338 | t_e.txt, the same address as the __d_alloc return pointer.
do_filp_open return pointer = 0xffff8bd728c76338 | t_e.txt.

t_m.txt miss, insert.</pre>
<pre><code class="language-c">char n3[] = "/tmp/t_m.txt";

f[2] = open(n3, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
open_entry: do_filp_open entry pointer = 0xffff8bd546392020 | /tmp/t_m.txt
d_lookup entry from lookup_entry: hash 2543581516 length 7 name t_m.txt
d_lookup return from lookup_ret: NULL
alloc_entry: __d_alloc entry pointer = 0xffff8bd546392025
alloc_ret: __d_alloc return pointer = 0xffff8bd728c763f8
__d_add entry from d_add_entry: 0xffff8bd728c763f8 | t_m.txt
Map
"/tmp/t_m.txt" @ 0xffff8bd546392020 -&gt; d_lookup (t_m.txt, 7, 2543581516) -&gt; NULL -&gt; __d_alloc entry 0xffff8bd546392025 -&gt; __d_alloc return 0xffff8bd728c763f8 -&gt; __d_add 0xffff8bd728c763f8.

Derivation.
0xffff8bd546392025 - 0xffff8bd546392020 = 0x5 = 5
"/tmp/" length = 5

The entry pointer is 0xffff8bd546392020 and the string is /tmp/t_m.txt, so the kernel copy for this call is fixed to that address. The lookup key is t_m.txt with length 7 and hash 2543581516, so the lookup uses 7 bytes and not 12. The lookup returns NULL, so the cache has no entry for that key at this time. The allocation source pointer is 0xffff8bd546392025, which is 0xffff8bd546392020 + 5; that 5 matches the length of "/tmp/", so the copy source begins at the filename part after the "/tmp/" prefix in the same string. The allocation return pointer is 0xffff8bd728c763f8, which is distinct from 0xffff8bd546392020. The insert line uses 0xffff8bd728c763f8, so the same new address is placed into the dcache.

a.txt miss, memcpy, insert (loopback ext2).</pre>
<pre><code class="language-c">char n5[] = "/mnt/loopfs/a.txt";

f[5] = open(n5, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
open_entry: do_filp_open entry pointer = 0xffff8bd546392020 | /mnt/loopfs/a.txt
d_lookup entry from lookup_entry: hash 3711754354 length 5 name a.txt
d_lookup return from lookup_ret: NULL
alloc_entry: __d_alloc entry pointer = 0xffff8bd54639202c
alloc_ret: __d_alloc return pointer = 0xffff8bd728c76cf8
__d_add entry from d_add_entry: 0xffff8bd728c76cf8 | a.txt
open_ret: do_filp_open return pointer = 0xffff8bd728c76cf8 | a.txt

Derivation.
0xffff8bd54639202c - 0xffff8bd546392020 = 0xC = 12
"/mnt/loopfs/" length = 12
0xffff8bd728c76cf8 = __d_alloc return pointer = __d_add entry pointer = do_filp_open return pointer

The entry pointer is 0xffff8bd546392020 and the string is /mnt/loopfs/a.txt. The lookup key is a.txt with length 5 and hash 3711754354, so the lookup uses 5 bytes. The lookup returns NULL, so the cache has no entry for that key. The allocation source pointer is 0xffff8bd54639202c, which is 0xffff8bd546392020 + 12, so the filename part starts after the 12‑byte prefix /mnt/loopfs/. The allocation return pointer is 0xffff8bd728c76cf8. The insert line uses 0xffff8bd728c76cf8, and the return line matches it.

Cache hit: l_e.txt and t_e.txt before deletion.</pre>
<pre><code class="language-c">char n1[] = "l_e.txt";
char n2[] = "/tmp/t_e.txt";

// first opens happen earlier
f[3] = open(n1, O_RDONLY);

// later opens hit cache
f[0] = open(n1, O_RDONLY);
f[1] = open(n2, O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
d_lookup entry from lookup_entry: hash 440978933 length 7 name l_e.txt
d_lookup return from lookup_ret: 0xffff8bd7e94c8578 | l_e.txt
d_lookup entry from lookup_entry: hash 1830572521 length 7 name t_e.txt
d_lookup return from lookup_ret: 0xffff8bd728c76338 | t_e.txt

Derivation.
0xffff8bd7e94c8578 = earlier l_e.txt return pointer
0xffff8bd728c76338 = earlier t_e.txt return pointer

The lookup for l_e.txt returns 0xffff8bd7e94c8578, which equals the earlier return pointer for l_e.txt. The lookup for t_e.txt returns 0xffff8bd728c76338, which equals the earlier return pointer for t_e.txt.

Cache deletion via unlink.</pre>
<pre><code class="language-c">unlink("l_e.txt");
unlink("/tmp/t_e.txt");</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
d_delete entry from d_delete_entry: 0xffff8bd7e94c8578 | l_e.txt
d_delete entry from d_delete_entry: 0xffff8bd728c76338 | t_e.txt
no d_drop entry lines observed in this run

Derivation.
0xffff8bd7e94c8578 = cached l_e.txt pointer from hit
0xffff8bd728c76338 = cached t_e.txt pointer from hit

The delete line for l_e.txt uses 0xffff8bd7e94c8578. The delete line for t_e.txt uses 0xffff8bd728c76338. No d_drop line appears in this run.

Cache eviction via drop_caches.</pre>
<pre><code class="language-c">drop_caches_if_root();
// writes "2\n" to /proc/sys/vm/drop_caches</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
open_entry: do_filp_open entry pointer = 0xffff8bd546392020 | /proc/sys/vm/drop_caches
open_ret: do_filp_open return pointer = 0xffff8bd6fce05db8 | drop_caches
__dentry_kill entry from dentry_kill_entry: 0xffff8bd728c763f8 | t_m.txt
__dentry_kill entry from dentry_kill_entry: 0xffff8bd728c76938 | l_m.txt
__dentry_kill entry from dentry_kill_entry: 0xffff8bd7e94c8578 | l_e.txt
__dentry_kill entry from dentry_kill_entry: 0xffff8bd728c76338 | t_e.txt
__dentry_kill entry from dentry_kill_entry: 0xffff8bd728c76cf8 | a.txt
matrix_open (129968): drop_caches: 2

Derivation.
0xffff8bd728c763f8 = t_m.txt pointer
0xffff8bd728c76938 = l_m.txt pointer
0xffff8bd7e94c8578 = l_e.txt pointer
0xffff8bd728c76338 = t_e.txt pointer
0xffff8bd728c76cf8 = a.txt pointer

The control file open is 0xffff8bd546392020 | /proc/sys/vm/drop_caches and returns 0xffff8bd6fce05db8 | drop_caches. The eviction lines show __dentry_kill for the five pointers above.

Cache rebuild after eviction: t_e.txt.</pre>
<pre><code class="language-c">drop_caches_if_root();
sleep(1);

// reopen after eviction
f[0] = open("l_e.txt", O_RDONLY);
f[1] = open("/tmp/t_e.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
d_lookup entry from lookup_entry: hash 1830572521 length 7 name t_e.txt
alloc_entry: __d_alloc entry pointer = 0xffff8bd546392025
alloc_ret: __d_alloc return pointer = 0xffff8bd728c76338
__d_add entry from d_add_entry: 0xffff8bd728c76338 | t_e.txt
open_ret: do_filp_open return pointer = 0xffff8bd728c76338 | t_e.txt

Restated pre-eviction t_e.txt pointer used for inequality: do_filp_open return pointer =
0xffff8bd728c76338 | t_e.txt

Derivation.
0xffff8bd728c76338 = 0xffff8bd728c76338

The post-eviction lookup for t_e.txt returns 0xffff8bd728c76338, which equals the pre-eviction pointer 0xffff8bd728c76338 in this run.

Post-eviction lookup: l_e.txt.</pre>
<pre><code class="language-c">drop_caches_if_root();
sleep(1);

// reopen after eviction
f[0] = open("l_e.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
open_entry: do_filp_open entry pointer = 0xffff8bd546392020 | l_e.txt
__d_lookup_rcu entry from lookup_rcu_entry: hash 440978933 length 7 name l_e.txt
open_ret: do_filp_open return pointer = 0xffff8bd7e94c8db8 | l_e.txt

Restated pre-eviction l_e.txt pointer used for inequality: do_filp_open return pointer =
0xffff8bd7e94c8578 | l_e.txt

Derivation.
0xffff8bd7e94c8db8 != 0xffff8bd7e94c8578

The post-eviction lookup uses __d_lookup_rcu with hash 440978933 length 7 name l_e.txt, then returns 0xffff8bd7e94c8db8.

Hash keys used in Run A.</pre>
<pre><code class="language-c">// these names are opened in this run:
open("l_e.txt", O_RDONLY);
open("/tmp/t_e.txt", O_RDONLY);
open("l_m.txt", O_RDONLY);
open("/tmp/t_m.txt", O_RDONLY);
open("/mnt/loopfs/a.txt", O_RDONLY);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
d_lookup entry from lookup_entry: hash 440978933 length 7 name l_e.txt
d_lookup entry from lookup_entry: hash 1830572521 length 7 name t_e.txt
d_lookup entry from lookup_entry: hash 2166850383 length 7 name l_m.txt
d_lookup entry from lookup_entry: hash 2543581516 length 7 name t_m.txt
d_lookup entry from lookup_entry: hash 3711754354 length 5 name a.txt

Each hash line is printed at lookup entry with name and length, so each hash is tied to the exact key shown: l_e.txt (7, 440978933), t_e.txt (7, 1830572521), l_m.txt (7, 2166850383), t_m.txt (7, 2543581516), a.txt (5, 3711754354).

Run B: minimal_open (target_comm=minimal_open)

Long filename: allocation, copy, cache hit.</pre>
<pre><code class="language-c">snprintf(filename, sizeof(filename),
         "test_file_very_long_name_to_force_external_allocation_%ld", now);
int fd = open(filename, O_RDWR | O_CREAT, 0644);
sleep(5);</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Probe output (trace_do_filp_open.c):
open_entry: do_filp_open entry pointer = 0xffff8bd55197c020 | test_file_very_long_name_to_force_external_allocation_1770418995
d_lookup entry from lookup_entry: hash 3008531989 length 64 name test_file_very_long_name_to_force_external_allocation_1770418995
d_lookup return from lookup_ret: NULL
alloc_entry: __d_alloc entry pointer = 0xffff8bd55197c020
alloc_ret: __d_alloc return pointer = 0xffff8bd556040f18
__d_add entry from d_add_entry: 0xffff8bd556040f18 | test_file_very_long_name_to_force_external_allocation_1770418995
open_ret: do_filp_open return pointer = 0xffff8bd556040f18 | test_file_very_long_name_to_force_external_allocation_1770418995
d_lookup return from lookup_ret: 0xffff8bd556040f18 | test_file_very_long_name_to_force_external_allocation_1770418995

Derivation.
0xffff8bd556040f18 = __d_alloc return pointer = __d_add entry pointer = do_filp_open return pointer = d_lookup return pointer

The entry pointer is 0xffff8bd55197c020 and the string is the full long filename, so the kernel copy is fixed to that address. The lookup key is the long filename with length 64 and hash 3008531989, so the key and length are explicit. The lookup returns NULL, so the cache has no entry for that key on first use. The allocation source pointer is 0xffff8bd55197c020, which equals the string pointer, so the copy source is the start of the long name. The allocation return pointer is 0xffff8bd556040f18, which is new storage. The insert line uses 0xffff8bd556040f18, and the return line matches it. The later d_lookup return line also returns 0xffff8bd556040f18, so the cache hit reuses the same pointer. The equality chain is 0xffff8bd556040f18 = __d_alloc return = __d_add entry = do_filp_open return = d_lookup return.

Summary

Memcpy: t_e.txt, a.txt, long filename.

Cache build-up: t_e.txt, t_m.txt, l_m.txt, a.txt, post-eviction t_e.txt, long filename.

Cache hit: l_e.txt, t_e.txt, long filename.

Cache miss: t_e.txt, t_m.txt, l_m.txt, a.txt, long filename.

Cache delete: l_e.txt, t_e.txt.

Cache eviction: l_e.txt, t_e.txt, t_m.txt, l_m.txt, a.txt.

Cache rebuild: t_e.txt.

Proofs

Proof 1: memcpy of filename into dentry storage.

Evidence (t_e.txt): __d_alloc entry pointer = 0xffff8bd546392025 __d_alloc return pointer =
0xffff8bd728c76338 __d_add entry: 0xffff8bd728c76338 | t_e.txt do_filp_open return pointer =
0xffff8bd728c76338 | t_e.txt

Derivation: 0xffff8bd728c76338 = __d_alloc return pointer 0xffff8bd728c76338 = __d_add entry pointer
0xffff8bd728c76338 = do_filp_open return pointer

Evidence (a.txt): __d_alloc entry pointer = 0xffff8bd54639202c __d_alloc return pointer =
0xffff8bd728c76cf8 __d_add entry: 0xffff8bd728c76cf8 | a.txt do_filp_open return pointer =
0xffff8bd728c76cf8 | a.txt

Derivation: 0xffff8bd728c76cf8 = __d_alloc return pointer 0xffff8bd728c76cf8 = __d_add entry pointer
0xffff8bd728c76cf8 = do_filp_open return pointer

Evidence (long filename): __d_alloc entry pointer = 0xffff8bd55197c020 __d_alloc return pointer =
0xffff8bd556040f18 __d_add entry: 0xffff8bd556040f18 |
test_file_very_long_name_to_force_external_allocation_1770418995 do_filp_open return pointer =
0xffff8bd556040f18 | test_file_very_long_name_to_force_external_allocation_1770418995

Derivation: 0xffff8bd556040f18 = __d_alloc return pointer 0xffff8bd556040f18 = __d_add entry pointer
0xffff8bd556040f18 = do_filp_open return pointer

Proof 2: cache build-up on miss.

Evidence: d_lookup return: NULL __d_add entry: 0xffff8bd728c76338 | t_e.txt

d_lookup return: NULL __d_add entry: 0xffff8bd728c763f8 | t_m.txt

d_lookup return: NULL __d_add entry: 0xffff8bd728c76938 | l_m.txt

d_lookup return: NULL __d_add entry: 0xffff8bd728c76cf8 | a.txt

d_lookup return: NULL __d_add entry: 0xffff8bd556040f18 |
test_file_very_long_name_to_force_external_allocation_1770418995

Proof 3: cache miss.

Evidence: d_lookup return: NULL (t_e.txt) d_lookup return: NULL (t_m.txt) d_lookup return: NULL
(l_m.txt) d_lookup return: NULL (a.txt) d_lookup return: NULL (long filename)

Proof 4: cache hit.

Evidence: d_lookup entry: hash 440978933 length 7 name l_e.txt d_lookup return: 0xffff8bd7e94c8578 |
l_e.txt

d_lookup entry from lookup_entry: hash 1830572521 length 7 name t_e.txt
d_lookup return from lookup_ret: 0xffff8bd728c76338 | t_e.txt

d_lookup entry: hash 3008531989 length 64 name
test_file_very_long_name_to_force_external_allocation_1770418995 d_lookup return pointer =
0xffff8bd556040f18

Proof 5: cache delete.

Evidence: d_delete entry: 0xffff8bd7e94c8578 | l_e.txt d_delete entry: 0xffff8bd728c76338 | t_e.txt

Proof 5b: cache eviction (drop_caches).

Evidence: do_filp_open entry pointer = 0xffff8bd546392020 | /proc/sys/vm/drop_caches do_filp_open
return pointer = 0xffff8bd6fce05db8 | drop_caches __dentry_kill entry: 0xffff8bd7e94c8578 | l_e.txt
__dentry_kill entry: 0xffff8bd728c76338 | t_e.txt __dentry_kill entry: 0xffff8bd728c763f8 | t_m.txt
__dentry_kill entry: 0xffff8bd728c76938 | l_m.txt __dentry_kill entry: 0xffff8bd728c76cf8 | a.txt

Proof 5c: cache rebuild after eviction (t_e.txt).

Evidence: d_lookup entry: hash 1830572521 length 7 name t_e.txt d_lookup return: NULL __d_alloc
entry pointer = 0xffff8bd546392025 __d_alloc return pointer = 0xffff8bd728c76338 __d_add entry:
0xffff8bd728c76338 | t_e.txt do_filp_open return pointer = 0xffff8bd728c76338 | t_e.txt

Proof 6: long filename behavior.

Evidence: d_lookup entry: hash 3008531989 length 64 name
test_file_very_long_name_to_force_external_allocation_1770418995 d_lookup return: NULL __d_alloc
entry pointer = 0xffff8bd55197c020 __d_alloc return pointer = 0xffff8bd556040f18 __d_add entry:
0xffff8bd556040f18 | test_file_very_long_name_to_force_external_allocation_1770418995 do_filp_open
return pointer = 0xffff8bd556040f18 |
test_file_very_long_name_to_force_external_allocation_1770418995

Proof 7: short filename behavior.

Evidence: d_lookup entry: hash 3711754354 length 5 name a.txt d_lookup return: NULL __d_alloc entry
pointer = 0xffff8bd54639202c __d_alloc return pointer = 0xffff8bd728c76cf8 __d_add entry:
0xffff8bd728c76cf8 | a.txt do_filp_open return pointer = 0xffff8bd728c76cf8 | a.txt

Derivation: 0xffff8bd54639202c - 0xffff8bd546392020 = 0xC = 12 "/mnt/loopfs/" length = 12

Wide-Screen Trace Appendix

Full Trace A (matrix_open, latest run)

Scope note: this trace lists the open sequence after the first drop_caches call. The earlier
creat(...) calls also execute do_filp_open and appear in dmesg, but they are not repeated here to
keep the step list aligned to the open sequence used for the claims.

1. do_filp_open entry | name pointer 0xffff8bd546392020 | name /tmp/t_e.txt | begin lookup for basename t_e.txt | caller line not recorded | current line not recorded | resume to caller with file pointer
2. __d_lookup_rcu entry | hash 2802308728 | length 3 | name tmp/t_e.txt | RCU prefix lookup | caller line not recorded | current line not recorded | resume to lookup path
3. __d_lookup_rcu entry | hash 1830572521 | length 7 | name t_e.txt | RCU basename lookup | caller line not recorded | current line not recorded | resume to lookup path
4. d_lookup entry | hash 1830572521 | length 7 | name t_e.txt | slow path lookup | caller line not recorded | current line not recorded | resume with hit/miss
5. d_lookup return | NULL | cache miss | miss triggers allocation | caller line not recorded | current line not recorded | resume to allocate dentry
6. __d_alloc entry | name pointer 0xffff8bd546392025 | basename start in /tmp/t_e.txt | allocate dentry name storage and copy | caller line not recorded | current line not recorded | resume with new dentry pointer
7. __d_alloc return | name pointer 0xffff8bd728c76338 | new dentry name storage for t_e.txt | allocation completed | caller line not recorded | current line not recorded | resume to insert into dcache
8. __d_add entry | name pointer 0xffff8bd728c76338 | name t_e.txt | insert into dcache hash | caller line not recorded | current line not recorded | resume to open path
9. do_filp_open return | name pointer 0xffff8bd728c76338 | name t_e.txt | returned file points to allocated name storage | caller line not recorded | current line not recorded | resume to user space
10. do_filp_open entry | name pointer 0xffff8bd546392020 | name /tmp/t_m.txt | begin lookup for basename t_m.txt | caller line not recorded | current line not recorded | resume with error or file
11. __d_lookup_rcu entry | hash 2802308728 | length 3 | name tmp/t_m.txt | RCU prefix lookup | caller line not recorded | current line not recorded | resume to lookup path
12. __d_lookup_rcu entry | hash 2543581516 | length 7 | name t_m.txt | RCU basename lookup | caller line not recorded | current line not recorded | resume to lookup path
13. d_lookup entry | hash 2543581516 | length 7 | name t_m.txt | slow path lookup | caller line not recorded | current line not recorded | resume with hit/miss
14. d_lookup return | NULL | cache miss | miss triggers allocation | caller line not recorded | current line not recorded | resume to allocate dentry
15. __d_alloc entry | name pointer 0xffff8bd546392025 | basename start in /tmp/t_m.txt | allocate dentry name storage and copy | caller line not recorded | current line not recorded | resume with new dentry pointer
16. __d_alloc return | name pointer 0xffff8bd728c763f8 | new dentry name storage for t_m.txt | allocation completed | caller line not recorded | current line not recorded | resume to insert into dcache
17. __d_add entry | name pointer 0xffff8bd728c763f8 | name t_m.txt | insert into dcache hash | caller line not recorded | current line not recorded | resume to open path
18. do_filp_open entry | name pointer 0xffff8bd546392020 | name l_m.txt | begin lookup for basename l_m.txt | caller line not recorded | current line not recorded | resume with error or file
19. __d_lookup_rcu entry | hash 2166850383 | length 7 | name l_m.txt | RCU basename lookup | caller line not recorded | current line not recorded | resume to lookup path
20. d_lookup entry | hash 2166850383 | length 7 | name l_m.txt | slow path lookup | caller line not recorded | current line not recorded | resume with hit/miss
21. d_lookup return | NULL | cache miss | miss triggers allocation | caller line not recorded | current line not recorded | resume to allocate dentry
22. __d_alloc entry | name pointer 0xffff8bd546392020 | basename start in l_m.txt | allocate dentry name storage and copy | caller line not recorded | current line not recorded | resume with new dentry pointer
23. __d_alloc return | name pointer 0xffff8bd728c76938 | new dentry name storage for l_m.txt | allocation completed | caller line not recorded | current line not recorded | resume to insert into dcache
24. __d_add entry | name pointer 0xffff8bd728c76938 | name l_m.txt | insert into dcache hash | caller line not recorded | current line not recorded | resume to open path
25. do_filp_open entry | name pointer 0xffff8bd546392020 | name /mnt/loopfs/a.txt | begin lookup for basename a.txt | caller line not recorded | current line not recorded | resume with file pointer
26. __d_lookup_rcu entry | hash 4289119505 | length 3 | name mnt/loopfs/a.txt | RCU prefix lookup | caller line not recorded | current line not recorded | resume to lookup path
27. __d_lookup_rcu entry | hash 1683324524 | length 6 | name loopfs/a.txt | RCU prefix lookup | caller line not recorded | current line not recorded | resume to lookup path
28. __d_lookup_rcu entry | hash 3711754354 | length 5 | name a.txt | RCU basename lookup | caller line not recorded | current line not recorded | resume to lookup path
29. d_lookup entry | hash 3711754354 | length 5 | name a.txt | slow path lookup | caller line not recorded | current line not recorded | resume with hit/miss
30. d_lookup return | NULL | cache miss | miss triggers allocation | caller line not recorded | current line not recorded | resume to allocate dentry
31. __d_alloc entry | name pointer 0xffff8bd54639202c | basename start in /mnt/loopfs/a.txt | allocate dentry name storage and copy | caller line not recorded | current line not recorded | resume with new dentry pointer
32. __d_alloc return | name pointer 0xffff8bd728c76cf8 | new dentry name storage for a.txt | allocation completed | caller line not recorded | current line not recorded | resume to insert into dcache
33. __d_add entry | name pointer 0xffff8bd728c76cf8 | name a.txt | insert into dcache hash | caller line not recorded | current line not recorded | resume to open path
34. do_filp_open return | name pointer 0xffff8bd728c76cf8 | name a.txt | returned file points to allocated name storage | caller line not recorded | current line not recorded | resume to user space
35. do_filp_open entry | name pointer 0xffff8bd546392020 | name l_e.txt | lookup for l_e.txt | caller line not recorded | current line not recorded | resume with file pointer
36. __d_lookup_rcu entry | hash 440978933 | length 7 | name l_e.txt | RCU lookup | caller line not recorded | current line not recorded | resume to lookup path
37. d_lookup return | pointer 0xffff8bd7e94c8578 | name l_e.txt | cache hit | caller line not recorded | current line not recorded | resume to open path
38. do_filp_open return | name pointer 0xffff8bd7e94c8578 | name l_e.txt | open returns cached dentry name pointer | caller line not recorded | current line not recorded | resume to user space
39. d_delete entry | pointer 0xffff8bd7e94c8578 | name l_e.txt | unlink removal | caller line not recorded | current line not recorded | resume to unlink path
40. d_delete entry | pointer 0xffff8bd728c76338 | name t_e.txt | unlink removal | caller line not recorded | current line not recorded | resume to unlink path
41. do_filp_open entry | name pointer 0xffff8bd546392020 | name /proc/sys/vm/drop_caches | open drop_caches for eviction | caller line not recorded | current line not recorded | resume to user space
42. do_filp_open return | name pointer 0xffff8bd6fce05db8 | name drop_caches | control file opened | caller line not recorded | current line not recorded | resume to user space
43. __dentry_kill entry | pointer 0xffff8bd7e94c8578 | name l_e.txt | eviction of cached dentry | caller line not recorded | current line not recorded | resume to shrinker
44. __dentry_kill entry | pointer 0xffff8bd728c76338 | name t_e.txt | eviction of cached dentry | caller line not recorded | current line not recorded | resume to shrinker
45. do_filp_open entry | name pointer 0xffff8bd546392020 | name l_e.txt | post-eviction lookup | caller line not recorded | current line not recorded | resume with file pointer
46. __d_lookup_rcu entry | hash 440978933 | length 7 | name l_e.txt | RCU lookup after eviction | caller line not recorded | current line not recorded | resume to open path
47. do_filp_open return | name pointer 0xffff8bd7e94c8db8 | name l_e.txt | return pointer differs from pre-eviction pointer 0xffff8bd7e94c8578 | caller line not recorded | current line not recorded | resume to user space
48. do_filp_open entry | name pointer 0xffff8bd546392020 | name /tmp/t_e.txt | post-eviction lookup | caller line not recorded | current line not recorded | resume with file pointer
49. d_lookup entry | hash 1830572521 | length 7 | name t_e.txt | slow path lookup | caller line not recorded | current line not recorded | resume with hit/miss
50. d_lookup return | NULL | miss post-eviction | triggers rebuild | caller line not recorded | current line not recorded | resume to allocate dentry
51. __d_alloc entry | name pointer 0xffff8bd546392025 | basename pointer | allocate new name storage | caller line not recorded | current line not recorded | resume with new dentry pointer
52. __d_alloc return | name pointer 0xffff8bd728c76338 | new name storage for t_e.txt | allocation completed | caller line not recorded | current line not recorded | resume to insert into dcache
53. __d_add entry | name pointer 0xffff8bd728c76338 | name t_e.txt | insert into dcache | caller line not recorded | current line not recorded | resume to open path
54. do_filp_open return | name pointer 0xffff8bd728c76338 | name t_e.txt | rebuilt pointer differs from pre-eviction pointer 0xffff8bd728c76338 | caller line not recorded | current line not recorded | resume to user space

Symbol availability proof (from this machine)

Kernel headers and sources:

uname -r: 6.14.0-37-generic /usr/src contains linux-headers-6.14.0-37-generic /usr/src contains
linux-source-6.8.0

kptr_restrict: 1 perf_event_paranoid: 4

Symbols in /proc/kallsyms:

__d_add: ffffffff89beaaa0 (local symbol, type t) d_add: ffffffff89beaca0 (global symbol, type T)
d_rehash: ffffffff89bea3e0 (global symbol, type T) d_add_ci: ffffffff89becf20 (global symbol, type
T) full_name_hash: ffffffff89bd5010 (global symbol, type T)

Why __d_add is not in available_filter_functions: available_filter_functions is the ftrace function
list, not a full symbol list. It only includes functions that ftrace exposes (non-inlined,
traceable, and globally visible). __d_add is present as a local symbol in kallsyms, so kprobe can
attach to it, but ftrace does not list it.

What We Failed To Observe And Why

1. We did not observe a __d_add line for l_e.txt in the post-eviction rebuild phase. The post-eviction lookup is visible on the RCU path and returns a new pointer, but an explicit insert line for l_e.txt was not printed in this run. This is why the l_e.txt section is phrased as a post-eviction lookup, not an explicit insert.
2. We did not observe any d_drop entry lines for these names. The d_delete lines are present in the data, but d_drop did not fire for these paths in this run.
3. We did not observe any full_name_hash return lines in this run. The full_name_hash kretprobe is registered, but the function may be inlined or bypassed in this path on this kernel build. Hash values are still recorded via d_lookup entry, __d_lookup entry, and __d_lookup_rcu entry, which report the key hash and length used.

Proofs from the latest run (commands + results):</pre>
<pre><code class="language-text">sudo dmesg | rg -n "__d_add entry: .*l_e.txt"
&lt;no output&gt;

sudo dmesg | rg -n "d_drop entry"
&lt;no output&gt;

sudo dmesg | rg -n "full_name_hash return"
&lt;no output&gt;</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Post-eviction l_e.txt lookup/return is visible even without __d_add:</pre>
<pre><code class="language-text">sudo dmesg | rg -n "__d_lookup_rcu entry:.*l_e.txt|\[O\] OUT: .*l_e.txt"
15:[33032.402797] __d_lookup_rcu entry: hash 440978933 length 7 name l_e.txt
17:[33032.402853] [O] OUT: 0xffff8bd54e0c74b8 | l_e.txt
35:[33033.423905] __d_lookup_rcu entry: hash 440978933 length 7 name l_e.txt
37:[33033.423931] [O] OUT: 0xffff8bd7e94c8578 | l_e.txt
149:[33036.444278] __d_lookup_rcu entry: hash 440978933 length 7 name l_e.txt
151:[33036.444304] [O] OUT: 0xffff8bd7e94c8db8 | l_e.txt</code></pre>
<pre style="white-space: pre-wrap; word-wrap: break-word; margin: 0; font-family: monospace;">

Explanation: the repeated __d_lookup_rcu entries show the lookup key for l_e.txt after eviction, and the [O] OUT lines show the return pointer seen by do_filp_open. The change from 0xffff8bd54e0c74b8 and 0xffff8bd7e94c8578 to 0xffff8bd7e94c8db8 records a new return pointer after eviction without an __d_add line in this run.</pre>
  </div>

</body>

</html>
